
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TradeVRS - Professional Trade Intelligence Platform</title>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* ---------------------------
       Base + Typography
    --------------------------- */
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      font-family:'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
      background:#FFFFFF;color:#1A1A1A
    }
    a{text-decoration:none;color:inherit}
    /* ---------------------------
       Header
    --------------------------- */
    .header{
      background:linear-gradient(135deg,#1A365D 0%,#2C5282 100%);
      padding:20px 28px;display:flex;align-items:center;justify-content:space-between;
      box-shadow:0 4px 6px rgba(0,0,0,.07)
    }
    .logo-section{display:flex;align-items:center;gap:24px}
    .logo{font-family:'Crimson Text',serif;font-size:26px;color:#fff;letter-spacing:.5px}
    .divider{width:1px;height:26px;background:rgba(255,255,255,.25)}
    /* Tagline (Visualization | Research | Strategy) */
    .tagline{display:inline-flex;align-items:center;gap:16px}
    .tagline .tag em{font-style:italic;font-weight:600;color:rgba(255,255,255,.95);font-size:12px;letter-spacing:.3px}
    .tagline .sep{width:2px;height:14px;background:#EDC650;border-radius:1px;display:inline-block}

    .header-right{display:flex;align-items:center;gap:12px}
    .user-info{color:rgba(255,255,255,.92);font-size:13px;display:flex;gap:10px;align-items:center}
    .user-divider{width:1px;height:14px;background:rgba(255,255,255,.35)}
    /* API status */
    .api-status{display:flex;align-items:center;gap:6px;padding:6px 10px;border-radius:4px;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.15);color:#E8EEF8;font-size:11px}
    .status-dot{width:6px;height:6px;border-radius:50%;background:#48BB78;box-shadow:0 0 0 2px rgba(72,187,120,.2)}
    /* API key field */
    .api-key-input-wrapper{display:flex;align-items:center;background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.15);border-radius:4px;height:32px}
    .api-key-label{padding:0 10px;border-right:1px solid rgba(255,255,255,.12);color:rgba(255,255,255,.8);
      font-size:11px;text-transform:uppercase;letter-spacing:.5px}
    .api-key-input{background:transparent;border:none;color:#fff;padding:0 10px;height:100%;width:200px;outline:none;font-size:12px}
    .api-key-input::placeholder{color:rgba(255,255,255,.5)}
    .api-key-save-btn{height:100%;border:none;border-left:1px solid rgba(255,255,255,.12);padding:0 12px;
      font-size:11px;font-weight:600;color:rgba(255,255,255,.8);background:transparent;cursor:pointer}
    .api-key-input-wrapper.has-key{background:rgba(72,187,120,.16);border-color:rgba(72,187,120,.35)}
    .api-key-input-wrapper.has-key .api-key-label{color:rgba(144,238,179,.95);border-right-color:rgba(72,187,120,.2)}
    .api-key-input-wrapper.has-key .api-key-save-btn{color:rgba(144,238,179,.9)}
    /* ---------------------------
       Nav
    --------------------------- */
    .nav{background:#2D3748;border-bottom:1px solid #E2E8F0;display:flex;gap:6px;padding:0 28px}
    .nav-tab{color:#A0AEC0;padding:14px 18px;border-bottom:3px solid transparent;font-size:13px;font-weight:500}
    .nav-tab.active{color:#fff;border-bottom-color:#EDC650;background:rgba(255,255,255,.08)}
    /* ---------------------------
       Main layout
    --------------------------- */
    /* Reduce the right column width by 10% (200px → 180px) and the left column width by ~5% (300px → 285px) */
    .layout{display:grid;grid-template-columns:285px 1fr 180px;min-height:calc(100vh - 120px)}
    .sidebar,.filters-panel{background:#F8F9FA;overflow:visible;max-height:calc(100vh - 120px)}
    .sidebar{border-right:1px solid #E2E8F0;padding:22px}
    .filters-panel{border-left:1px solid #E2E8F0;padding:22px}
    .content{padding:21px 26px 26px 26px;overflow-y:auto;max-height:calc(100vh - 120px);background:#fff}
    .section-title{font-size:13px;font-weight:700;color:#003366;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;
      padding-bottom:8px;border-bottom:2px solid #003366}
    .form-group{margin-bottom:14px}
    .form-label{display:block;font-size:12px;font-weight:600;color:#374151;text-transform:uppercase;letter-spacing:.5px;margin-bottom:6px}
    .form-control{width:100%;padding:8px 10px;border:1px solid #CED4DA;border-radius:4px;background:#fff;font-size:14px}
    .form-control:focus{outline:none;border-color:#003366;box-shadow:0 0 0 2px rgba(0,51,102,.1)}
    select.form-control[multiple]{min-height:120px}
    .button-row{display:flex;gap:8px}
    .btn{padding:8px 12px;border:none;border-radius:4px;font-size:13px;font-weight:600;cursor:pointer}
    .btn-primary{background:#003366;color:#fff}
    .btn-primary:hover{background:#002244}
    .btn-secondary{background:#fff;color:#003366;border:1px solid #003366}
    .btn-secondary:hover{background:#F0F4F8}
    /* Active filter tags (left) */
    .filter-tag{display:inline-flex;gap:6px;align-items:center;padding:4px 8px;margin:4px 6px 0 0;border:1px solid #003366;border-radius:4px;background:#E7F3FF;color:#003366;font-size:12px}
    .filter-tag .x{font-weight:700;cursor:pointer}

    /* Limit the Active Filters display to two rows with scrolling */
    #activeTags{
      display:flex;
      flex-wrap:wrap;
      align-content:flex-start;
      overflow-y:auto;
      overflow-x:hidden;
      max-height:60px;
      padding-right:4px;
      padding-top:0;
      padding-bottom:4px;
      margin-top:0;
      margin-bottom:6px;
    }
    /* Dynamic filter pills (right) */
    .pill-wrap{display:flex;flex-wrap:wrap;gap:8px}
    .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 12px;border-radius:999px;border:1px solid #E2E8F0;background:#F0F0F0;cursor:pointer;font-size:12px}
    .pill .dot{
      width:8px;
      height:8px;
      border-radius:50%;
      background:#A0AEC0;
      /* Prevent the colored dot from stretching when a pill spans multiple lines. */
      flex: 0 0 8px;
      align-self: center;
    }
    .pill.active{background:#003366;color:#fff;border-color:#003366}
    .pill.active .dot{background:#EDC650;box-shadow:0 0 0 2px rgba(237,198,80,.25)}
    .filters-title{font-size:13px;font-weight:700;color:#003366;text-transform:uppercase;letter-spacing:1px;margin-bottom:10px;padding-bottom:8px;border-bottom:2px solid #003366}
    /* Cards / tables */
    .pivot-card{background:#FFFFFF;border:1px solid #DEE2E6;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.05);margin-bottom:20px;overflow:hidden}
    .pivot-header{background:#F8F9FA;border-bottom:1px solid #DEE2E6;padding:14px 16px;display:flex;justify-content:space-between;align-items:center}
    .pivot-title{font-weight:600;color:#003366}
    .pivot-toggle{display:flex;gap:8px;align-items:center}
    .pivot-toggle label{font-size:12px;color:#6C757D;font-weight:500}
    .pivot-toggle select{padding:4px 8px;border:1px solid #CED4DA;border-radius:4px;font-size:12px;background:#fff}
    table{width:100%;border-collapse:collapse}
    th{background:#003366;color:#fff;padding:12px;text-align:center;font-size:12px;font-weight:600;text-transform:uppercase;letter-spacing:.4px}
    th:first-child{text-align:left}
    th small{display:block;font-weight:400;opacity:.9;text-transform:none;letter-spacing:0}
    td{padding:12px;border-bottom:1px solid #E9ECEF;font-size:14px;color:#1A1A1A;text-align:center}
    td:first-child{text-align:left;color:#003366;font-weight:500}
    tr:hover{background:#F8F9FA}
    tr.summary-row{background:#F0F0F0;font-weight:600}
    tr.summary-row:hover{background:#E8E8E8}
    /* Percent coloring */
    .pct-up{color:#28A745;font-weight:600}
    .pct-up::before{content:"▲ ";font-size:10px;margin-right:2px}
    .pct-down{color:#DC3545;font-weight:600}
    .pct-down::before{content:"▼ ";font-size:10px;margin-right:2px}
    /* Hide tables until fetch */
    .content .results-wrap{display:none; position:relative}
    /* Canvas for polygon animation in the results area */
    #bgAnimation{
      position:absolute;
      top:0;
      left:0;
      width:100%;
      height:100%;
      z-index:0;
      pointer-events:none;
    }

    /* When the results area is in placeholder mode (no data yet), give it a minimum
       height so that the animated background is visible even when no pivot tables
       are shown. */
    .results-wrap.placeholder-state {
      /* Give the placeholder area a large minimum height so the animation fills
         the majority of the center column. The calculation subtracts header
         and margin space to approximate full viewport height. */
      min-height: calc(100vh - 160px);
      /* Remove any static background on the placeholder state. The gradient will now
         be drawn dynamically on the canvas itself so that it can extend beyond
         the results area into the sidebars and header. */
      position: relative;
      background: none;
    }
    /* Date input with icon */
    .date-wrap{position:relative}
    .date-wrap input[type="month"]{padding-right:36px}
    .date-wrap .icon{position:absolute;right:8px;top:50%;transform:translateY(-50%);opacity:.65}
    /* Responsive: hide side panels under 1200px */
    @media (max-width:1200px){
      .layout{grid-template-columns:1fr}
      .sidebar,.filters-panel{display:none}
    }


    /* Honor reduced-motion preferences: when the user indicates reduced motion,
       hide the animated canvas entirely so only the static background remains. */
    @media (prefers-reduced-motion: reduce) {
      #bgAnimation { display: none !important; }
    }

/* ===== Compact table overrides ===== */
:root {
  --pivot-font-size: 12px;
  --pivot-header-font-size: 12px;
  --pivot-cell-pad-y: 4px;
  --pivot-header-pad-y: 6px;
}

#slicedPivotContainer h3,
#slicedPivotValueContainer h3,
#slicedPivotAvgContainer h3,
#negligibilityContainer h3,
#slicedNegligibilityContainer h3 {
  font-size: 16px;
  line-height: 1.15;
  margin: 6px 0 8px;
}

#pivotContainer th,
#slicedPivotContainer th,
#slicedPivotValueContainer th,
#slicedPivotAvgContainer th,
#negligibilityContainer th,
#slicedNegligibilityContainer th {
  font-size: var(--pivot-header-font-size);
  padding: var(--pivot-header-pad-y) 6px;
  line-height: 1.05;
  vertical-align: middle;
}

#pivotContainer td,
#slicedPivotContainer td,
#slicedPivotValueContainer td,
#slicedPivotAvgContainer td,
#negligibilityContainer td,
#slicedNegligibilityContainer td {
  font-size: var(--pivot-font-size);
  padding: var(--pivot-cell-pad-y) 6px;
  line-height: 1.15;
  vertical-align: middle;
}

#pivotContainer th small,
#slicedPivotContainer th small,
#slicedPivotValueContainer th small,
#slicedPivotAvgContainer th small,
#negligibilityContainer th small,
#slicedNegligibilityContainer th small {
  display: block;
  font-size: 0.78em;
  line-height: 1;
  opacity: 0.85;
  margin-top: 2px;
}

.pivot-title { margin-bottom: 4px; }
.pivot-toggle { gap: 4px; }
.pivot-toggle span { font-size: 0.8em; }
.pivot-toggle select { font-size: 0.8em; padding: 2px 6px; height: 28px; }
.pivot-header { padding: 8px 12px !important; }

    /* Make dynamic filters scrollable when there are many pills.
       Each container will show up to approximately five pills before scrolling. */
    #pillCountries,
    #pillHts {
      /* Adjust the height of the dynamic filter scroll boxes to be roughly 5% taller than the original size. */
      max-height: 185px; /* 176px × 1.05 ≈ 184.8; rounded to 185px */
      overflow-y: auto;
      overflow-x: hidden;
    }

    /* Sign-in modal overlay styles */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.4);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 10000;
    }
    .modal-overlay.active {
      display: flex;
    }
    .sign-in-modal {
      background: #F8F9FA;
      border: 1px solid #DEE2E6;
      border-radius: 8px;
      padding: 20px 24px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
      width: 320px;
      max-width: 90%;
    }
    .sign-in-modal h2 {
      margin-bottom: 12px;
      font-size: 18px;
      font-weight: 600;
      color: #003366;
      text-align: center;
    }
    .sign-in-modal .form-group {
      margin-bottom: 12px;
    }
    .sign-in-modal label {
      display: block;
      font-size: 12px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 4px;
    }
    .sign-in-modal input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid #CED4DA;
      border-radius: 4px;
      background: #fff;
      font-size: 14px;
    }
    .sign-in-modal button {
      width: 100%;
      margin-top: 8px;
      padding: 8px;
      border: none;
      border-radius: 4px;
      font-size: 14px;
      font-weight: 600;
      background: #003366;
      color: #fff;
      cursor: pointer;
    }
    /* Connection status and loading indicator */
    .loading {
      display: none;
      color: #003366;
      font-weight: bold;
      padding: 10px;
    }
    .loading.active {
      display: block;
    }
    .connection-status {
      position: fixed;
      top: 12px;
      right: 12px;
      padding: 8px 12px;
      border-radius: 4px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 2px 6px rgba(0,0,0,0.1);
      font-size: 12px;
      z-index: 1000;
      border-left: 3px solid #003366;
    }
    .connection-status.connected {
      border-left-color: #48BB78;
    }
    .connection-status.disconnected {
      border-left-color: #DC3545;
    }
  </style>
</head>
<body>
  <!-- API connection status and loading indicator -->
  <div class="connection-status disconnected" id="connectionStatus">
    <span id="statusText">Connecting to API...</span>
  </div>
  <div class="loading" id="loadingIndicator">Loading data from secure API...</div>
  <!-- Header -->
  <header class="header">
    <div class="logo-section">
      <div class="logo">TradeVRS</div>
      <div class="divider"></div>
      <div class="tagline" role="presentation">
        <span class="tag"><em>Visualization</em></span>
        <span class="sep" aria-hidden="true"></span>
        <span class="tag"><em>Research</em></span>
        <span class="sep" aria-hidden="true"></span>
        <span class="tag"><em>Strategy</em></span>
      </div>
    </div>
    <div class="header-right">
      <div class="user-info">
        <span id="userName">Welcome, Sarah Mitchell</span>
        <span class="user-divider"></span>
        <span id="userOrg">Davis Polk &amp; Wardwell LLP</span>
      </div>
      <div class="api-status"><span class="status-dot"></span><span id="apiStatusText">API: 0/500</span></div>
      <div class="api-key-input-wrapper" id="apiKeyWrap">
        <label class="api-key-label" for="apiKey">API Key</label>
        <input id="apiKey" class="api-key-input" type="text" placeholder="Enter Census API key" />
        <button id="saveApiKey" class="api-key-save-btn">Save</button>
      </div>
    </div>
  </header>
  <!-- Nav -->
  <nav class="nav">
    <span class="nav-tab active">Trade Analysis β</span>
  </nav>

  <div class="layout">
    <!-- Left sidebar -->
    <aside class="sidebar">
      <div class="section-title">Search Parameters</div>

      <div class="form-group">
        <label class="form-label">HTS Codes</label>
        <input id="htsCodes" class="form-control" type="text" placeholder="Type HTS: 8541430010, 8541420010">
        <div class="button-row" style="margin-top:8px">
          <button id="addHTSBtn" class="btn btn-primary" type="button">Add</button>
          <button id="removeHTSBtn" class="btn btn-secondary" type="button">Remove</button>
        </div>
        <div id="htsTags" style="margin-top:6px"></div>
      </div>

      <div class="form-group">
        <label class="form-label">Country Search</label>
        <input id="countrySearch" class="form-control" type="text" placeholder="Type countries: India, Indonesia, Laos...">
        <select id="countrySelect" class="form-control" multiple style="margin-top:8px">
          <option disabled selected>Loading countries...</option>
        </select>
        <div class="button-row" style="margin-top:8px">
          <button id="addCountryBtn" class="btn btn-primary" type="button">Add Selected</button>
          <button id="clearAllCountries" class="btn btn-secondary" type="button">Clear All</button>
        </div>
      </div>

      <div class="form-group">
        <label class="form-label">Start Month</label>
        <div class="date-wrap">
          <input id="startDate" class="form-control" type="month">
        </div>
      </div>
      <div class="form-group">
        <label class="form-label">End Month</label>
        <div class="date-wrap">
          <input id="endDate" class="form-control" type="month">
        </div>
      </div>

      <div class="section-title" style="margin-top:14px">Active Filters</div>
      <div id="activeTags"></div>

      <div class="button-row" style="margin-top:9px">
        <button id="fetchBtn" class="btn btn-primary" type="button">Fetch Data</button>
        <button id="clearBtn" class="btn btn-secondary" type="button">Clear</button>
      </div>
    </aside>

    <!-- Main content -->
    <main class="content">
      <div id="results"></div>

      <!-- Results (hidden until fetch) -->
      <div class="results-wrap" id="resultsWrap">

        <!-- Quantity table -->
        <section class="pivot-card">
          <div class="pivot-header">
            <div class="pivot-title" id="qtyTitle">Quantity</div>
            <div class="pivot-toggle">
              <label>Quantity Unit:</label>
              <select id="unitToggle">
                <option value="2" selected>2nd Unit</option>
                <option value="1">1st Unit</option>
              </select>
            </div>
          </div>
          <div id="slicedPivotContainer"></div>
        </section>

        <!-- Value table -->
        <section class="pivot-card">
          <div class="pivot-header">
            <div class="pivot-title" id="valTitle">LDP Value (Dollars)</div>
            <div class="pivot-toggle">
              <label>Value Type:</label>
              <select id="valueToggle">
                <option value="ldp" selected>LDP Value</option>
                <option value="customs">Customs Value</option>
              </select>
            </div>
          </div>
          <div id="slicedPivotValueContainer"></div>
        </section>

        <!-- AUV table -->
        <section class="pivot-card">
          <div class="pivot-header">
            <div class="pivot-title" id="avgTitle">Average Unit Value</div>
          </div>
          <div id="slicedPivotAvgContainer"></div>
        </section>

        <!-- Negligibility -->
        <section class="pivot-card">
          <div class="pivot-header">
            <div class="pivot-title">Negligibility Analysis</div>
          </div>
          <div id="slicedNegligibilityContainer"></div>
        </section>

        <!-- Hidden duplicate download button; main CSV download is available in the Quick Actions panel -->
        <div class="button-row" style="margin-top:6px; display:none;">
          <button id="downloadBtn" class="btn btn-secondary" type="button" disabled>Download CSV</button>
        </div>
      </div>
    </main>

    <!-- Right panel -->
    <aside class="filters-panel">
      <div class="filters-title">Dynamic Filters</div>
      <div class="form-group">
        <label class="form-label">Country Filter</label>
        <div id="pillCountries" class="pill-wrap"></div>
      </div>
      <div class="form-group">
        <label class="form-label">HTS Filter</label>
        <div id="pillHts" class="pill-wrap"></div>
      </div>

      <div class="filters-title" style="margin-top:18px">Quick Actions</div>
      <div class="button-row" style="margin-top:8px;flex-direction:column">
        <button id="qaDownloadCSV" class="btn btn-secondary" type="button" disabled>Download CSV</button>
        <button id="qaSaveView" class="btn btn-secondary" type="button" disabled>Save View</button>
      </div>
    </aside>
  </div>

  <!-- Hidden containers kept for internal reuse by logic -->
  <div style="display:none">
    <div id="pivotContainer"></div>
    <div id="negligibilityContainer"></div>
  </div>

  <script>
    // ------------------- API status counter (session/day without API key) -------------------
    function updateApiCounterDisplay() {
      const wrap = document.getElementById('apiKeyWrap');
      const status = document.getElementById('apiStatusText');
      const key = document.getElementById('apiKey').value.trim();
      if (key) {
        wrap.classList.add('has-key');
        status.textContent = 'API: Active';
      } else {
        wrap.classList.remove('has-key');
        // show daily count
        const today = new Date().toISOString().slice(0,10);
        const data = JSON.parse(localStorage.getItem('tvrs_api_counter') || '{}');
        const count = (data[today] || 0);
        status.textContent = 'API: '+count+'/500';
      }
    }
    function bumpApiCounterIfNoKey() {
      const key = (document.getElementById('apiKey').value || '').trim();
      if (key) return;
      const today = new Date().toISOString().slice(0,10);
      const data = JSON.parse(localStorage.getItem('tvrs_api_counter') || '{}');
      data[today] = (data[today] || 0) + 1;
      localStorage.setItem('tvrs_api_counter', JSON.stringify(data));
      updateApiCounterDisplay();
    }
    document.getElementById('saveApiKey').addEventListener('click', updateApiCounterDisplay);
  </script>

  <!-- Sign-in modal markup -->
  <div id="signInOverlay" class="modal-overlay">
    <div class="sign-in-modal">
      <h2>Sign In</h2>
      <div class="form-group">
        <label for="signInFirstName">First Name</label>
        <input id="signInFirstName" type="text" placeholder="First name">
      </div>
      <div class="form-group">
        <label for="signInLastName">Last Name</label>
        <input id="signInLastName" type="text" placeholder="Last name">
      </div>
      <div class="form-group">
        <label for="signInOrg">Organization</label>
        <input id="signInOrg" type="text" placeholder="Organization name">
      </div>
      <button id="signInSubmit">Continue</button>
    </div>
  </div>

  <script>
    // Display the sign-in modal on page load and populate the header
    document.addEventListener('DOMContentLoaded', function() {
      const overlay = document.getElementById('signInOverlay');
      const submitBtn = document.getElementById('signInSubmit');
      const firstNameField = document.getElementById('signInFirstName');
      const lastNameField = document.getElementById('signInLastName');
      const orgField = document.getElementById('signInOrg');
      // Show the overlay immediately
      overlay.classList.add('active');
      // Focus the first field when shown
      setTimeout(() => { firstNameField.focus(); }, 0);
      submitBtn.addEventListener('click', function() {
        const first = firstNameField.value.trim();
        const last = lastNameField.value.trim();
        const org = orgField.value.trim();
        if(!first || !last || !org) {
          alert('Please enter your first name, last name and organization.');
          return;
        }
        // Update the header
        const nameSpan = document.getElementById('userName');
        const orgSpan = document.getElementById('userOrg');
        if(nameSpan) {
          nameSpan.textContent = 'Welcome, ' + first + ' ' + last;
        }
        if(orgSpan) {
          orgSpan.textContent = org;
        }
        // Hide the overlay
        overlay.classList.remove('active');
      });
    });
  </script>
<script>
  /*
   * Placeholder rendering for initial page load.
   * When the page is first opened there is no data to display in the central
   * pivots area. Without any tables the interface can feel empty, so we
   * populate the pivot containers with simple skeleton tables. Each table
   * contains three blank country rows followed by summary rows for
   * "Subject Imports", "Nonsubject Imports" and "Total Imports". These
   * placeholders will be automatically replaced when real data is fetched.
   */
  function renderPlaceholderCard(containerId){
    const container = document.getElementById(containerId);
    if(!container) return;
    let html = '<table><thead><tr>';
    // Create five columns: one for Country and four blank headings
    for(let i=0;i<5;i++){
      html += '<th style="text-align:' + (i===0?'left':'center') + '">' + (i===0? 'Country' : '&nbsp;') + '</th>';
    }
    html += '</tr></thead><tbody>';
    // Three placeholder country rows with labels "Country 1", "Country 2", "Country 3".  The first
    // column contains the label and aligns left; remaining columns are left blank.  These
    // labels help users understand how real data will appear in the pivot.
    const countryLabels = ['Country 1','Country 2','Country 3'];
    for(let r=0;r<countryLabels.length;r++){
      html += '<tr>';
      for(let c=0;c<5;c++){
        if(c===0){
          html += '<td style="text-align:left">' + countryLabels[r] + '</td>';
        } else {
          html += '<td style="text-align:center"></td>';
        }
      }
      html += '</tr>';
    }
    // Summary rows
    const labels = ['Subject Imports','Nonsubject Imports','Total Imports'];
    labels.forEach(label => {
      html += '<tr><td style="text-align:left">' + label + '</td>';
      for(let c=1;c<5;c++) html += '<td></td>';
      html += '</tr>';
    });
    html += '</tbody></table>';
    container.innerHTML = html;
  }
  function renderNegPlaceholder(){
    const container = document.getElementById('slicedNegligibilityContainer');
    if(!container) return;
    let html = '<table><thead><tr>';
    const heads = ['Country','Quantity','Share'];
    heads.forEach((h,idx) => {
      html += '<th style="text-align:' + (idx===0?'left':'center') + '">' + h + '</th>';
    });
    html += '</tr></thead><tbody>';
    // Four placeholder rows: the first shows "All Countries" followed by three
    // sample country rows labelled "Country 1", "Country 2" and "Country 3".  The
    // labels occupy the first column and align left; the remaining columns are
    // intentionally left blank.  This mirrors the real negligibility pivot and
    // helps users visualize the forthcoming data.
    const labels = ['All Countries','Country 1','Country 2','Country 3'];
    labels.forEach(label => {
      html += '<tr><td style="text-align:left">' + label + '</td><td></td><td></td></tr>';
    });
    html += '</tbody></table>';
    container.innerHTML = html;
  }

  /* ----- Subtle empty-state background (brand toned, low-CPU) ----- */
  // Initialize variables and cleanup array to track listeners/animations
  let __bgAnimId = null;
  let __bgCleanups = [];

  function initBackgroundAnimation() {
    const wrap = document.getElementById('resultsWrap');
    if (!wrap) return;
    // Only decorate the true empty state.
    if (!wrap.classList.contains('placeholder-state')) return;

    // Respect reduced-motion settings.
    const mql = window.matchMedia('(prefers-reduced-motion: reduce)');
    if (mql.matches) return;

    // Avoid double init if a canvas is already present.
    if (document.getElementById('bgAnimation')) return;

    // Canvas setup
    const canvas = document.createElement('canvas');
    canvas.id = 'bgAnimation';
    wrap.prepend(canvas);
    const ctx = canvas.getContext('2d', { alpha: true });

    // Palette (aligned to header/nav + accent)
    // Increase the opacity and size of dots/lines for improved visibility over the light background.
    const DOT_RGBA = 'rgba(44,82,130,0.24)'; // darkened color at moderate alpha
    const LINE_BASE = [44, 82, 130];            // #2C5282
    const MAX_DIST = 130;                        // slightly longer reach for connections
    const RADIUS   = 1.0;                        // slightly larger points for better legibility
    // Reference to the parent container (.content) that houses the results.
    const container = wrap.parentElement;
    // Constants controlling how far the gradient and animation extend beyond the
    // actual results area. Each direction is half of the total extra size so a
    // 200px horizontal extra means 100px overspill on both left and right. The
    // vertical extra applies only to the top so that the animation can blend
    // into the header area without spilling below the pivot tables. Adjust these
    // values if you want the wash to envelop more or less of the surrounding UI.
    const HORIZ_EXTRA = 200; // 100px on left, 100px on right
    const TOP_EXTRA   = 100; // 100px above the results area

    let particles = [];
    let last = 0;

    function lineRGBA(alpha) {
      return `rgba(${LINE_BASE[0]}, ${LINE_BASE[1]}, ${LINE_BASE[2]}, ${alpha})`;
    }

    function sizeCanvasAndParticles() {
      /*
       * Compute the size of both the container (.content) and the wrapper (.results-wrap)
       * and determine how much padding exists on each side. We then expand the canvas
       * width and height beyond that padding by fixed amounts so the animation
       * and gradient wash extend under the sidebars and up into the header. The
       * horizontal extra is split evenly on both sides; the vertical extra is
       * applied only to the top. The bottom remains flush with the results area
       * so that it aligns neatly with the pivot tables when they appear.
       */
      const containerRect = container.getBoundingClientRect();
      const wrapRect = wrap.getBoundingClientRect();
      // Differences between wrap and container on each side (in pixels)
      const diffLeft   = wrapRect.left   - containerRect.left;
      const diffRight  = containerRect.right  - wrapRect.right;
      const diffTop    = wrapRect.top    - containerRect.top;
      const diffBottom = containerRect.bottom - wrapRect.bottom;
      // Determine desired canvas dimensions
      const width  = Math.max(320, Math.floor(wrapRect.width  + diffLeft + diffRight + HORIZ_EXTRA));
      const height = Math.max(280, Math.floor(wrapRect.height + diffTop  + diffBottom + TOP_EXTRA));
      // Set canvas drawing dimensions
      canvas.width  = width;
      canvas.height = height;
      // Set rendered size and offsets so the canvas extends into the padding areas
      canvas.style.width  = width  + 'px';
      canvas.style.height = height + 'px';
      // Split the horizontal extra evenly on both sides
      const horizOffset = diffLeft + HORIZ_EXTRA / 2;
      // Shift upward by the top extra so the top of the canvas begins above the
      // results area, allowing the gradient to bleed under the header. We do not
      // apply the bottom extra here so the bottom stays aligned with the
      // results area.
      const vertOffset  = diffTop + TOP_EXTRA;
      canvas.style.left   = '-' + horizOffset + 'px';
      canvas.style.top    = '-' + vertOffset  + 'px';
      // Scale density with area: 80–140 particles, far fewer than before
      const area = width * height;
      // Increase the number of particles so the network feels more populated. We
      // allow between 100 and 180 nodes depending on the area. The divisor
      // controls how many pixels each node occupies — decreasing it yields
      // more particles. The minimum ensures that small viewports still have
      // enough points to form a visible lattice.
      const target = Math.max(100, Math.min(180, Math.round(area / 60000)));
      particles = new Array(target).fill(0).map(() => ({
        x: Math.random() * width,
        y: Math.random() * height,
        // Increase velocity by 50% so the animation moves faster. Previously ±0.05 per frame; now ±0.075.
        vx: (Math.random() - 0.5) * 0.15,
        vy: (Math.random() - 0.5) * 0.15
      }));
    }

    function onResize() {
      sizeCanvasAndParticles();
      draw(0);
    }
    window.addEventListener('resize', onResize);
    __bgCleanups.push(() => window.removeEventListener('resize', onResize));

    function onMqlChange(e) { if (e.matches) stopBackgroundAnimation(); }
    mql.addEventListener('change', onMqlChange);
    __bgCleanups.push(() => mql.removeEventListener('change', onMqlChange));

    // Removed the visibilitychange listener so the animation persists across tab switches.
    // Previously, the animation was stopped when the document became hidden, which led
    // to it not restarting when the user returned. Omitting this listener ensures
    // the particle network continues running even if the tab is backgrounded.

    sizeCanvasAndParticles();

    function draw(ts) {
      // If we've left the empty state, stop immediately.
      if (!wrap.classList.contains('placeholder-state')) { stopBackgroundAnimation(); return; }

      // Throttle to ~28 fps to keep CPU low.
      if (ts - last < 36) { __bgAnimId = requestAnimationFrame(draw); return; }
      last = ts;

      // Clear the canvas and repaint the gradient wash. We use a linear gradient
      // that matches the light neutral background of the UI. Because the canvas
      // extends beyond the results area, this gradient will also extend
      // underneath the header and sidebars.
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#FFFFFF');
      grad.addColorStop(1, '#F7F9FC');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Move + draw dots
      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];
        p.x += p.vx; p.y += p.vy;
        // Wrap around edges (gentler than bounce)
        if (p.x < 0) p.x = canvas.width; else if (p.x > canvas.width) p.x = 0;
        if (p.y < 0) p.y = canvas.height; else if (p.y > canvas.height) p.y = 0;

        ctx.beginPath();
        ctx.arc(p.x, p.y, RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = DOT_RGBA;
        ctx.fill();
      }

      // Lightweight connections (shorter reach, thinner strokes, faint alpha)
      for (let i = 0; i < particles.length; i++) {
        const a = particles[i];
        for (let j = i + 1; j < particles.length; j++) {
          const b = particles[j];
          const dx = a.x - b.x, dy = a.y - b.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < MAX_DIST * MAX_DIST) {
            const d = Math.sqrt(d2);
            // Use a slightly higher alpha and thicker lines so the network is perceptible against
            // the light backdrop while remaining understated.
            const alpha = 0.18 * (1 - d / MAX_DIST);
            ctx.strokeStyle = lineRGBA(alpha);
            ctx.lineWidth = 0.45;
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }
        }
      }

      __bgAnimId = requestAnimationFrame(draw);
    }

    __bgAnimId = requestAnimationFrame(draw);
  }

  function stopBackgroundAnimation() {
    if (__bgAnimId) { cancelAnimationFrame(__bgAnimId); __bgAnimId = null; }
    __bgCleanups.forEach(fn => { try { fn(); } catch(_) {} });
    __bgCleanups = [];
    const canvas = document.getElementById('bgAnimation');
    if (canvas) canvas.remove();
  }
  document.addEventListener('DOMContentLoaded', function(){
    try {
      if(!window.originalRows || !Array.isArray(window.originalRows) || window.originalRows.length === 0){
        const wrap = document.getElementById('resultsWrap');
        if(wrap){
          wrap.style.display = 'block';
          // Add placeholder state to give the area height
          wrap.classList.add('placeholder-state');
        }
        // Show pivot cards and populate them with placeholder tables.  The placeholders
        // mimic the real pivot layout with blank rows and summary labels so the
        // interface doesn't feel empty before any selections are made.  We also
        // apply a higher opacity to these placeholders so they subtly blend
        // with the animated background underneath.
        document.querySelectorAll('.pivot-card').forEach(el => {
          el.style.display = 'block';
          // Slightly reduce opacity so the background wash can peek through.
          el.style.opacity = '0.75';
        });
        // Render empty skeletons for each pivot container and negligibility.
        try {
          renderPlaceholderCard('slicedPivotContainer');
          renderPlaceholderCard('slicedPivotValueContainer');
          renderPlaceholderCard('slicedPivotAvgContainer');
          renderNegPlaceholder();
        } catch(_){ console.warn('Placeholder render failed', _); }
        // Start the background animation when there is no data yet.
        initBackgroundAnimation();
      }
    } catch(e){ console.error('Error rendering placeholders', e); }
  });
</script>
  <script>

/* ---------- API configuration and dynamic data ---------- */
// Configuration used to connect to the backend API for countries and units.
const API_CONFIG = {
  baseUrl: 'https://tradevrs-backend.vercel.app',
  apiKey: 'test-key-123',
  endpoints: {
    health: '/api',
    countries: '/api/countries',
    units: '/api/units'
  }
};
// Variables that will be filled once connectToAPI() is executed.
let countriesList = [];
let countryNameMap = {};
let unitNameMap = {};
let isApiConnected = false;

/* ---------- State ---------- */
/* ---------- API connection function ---------- */
async function connectToAPI() {
  const statusEl = document.getElementById('connectionStatus');
  const statusText = document.getElementById('statusText');
  const loadingEl = document.getElementById('loadingIndicator');
  try {
    if (loadingEl) loadingEl.classList.add('active');
    if (statusText) statusText.textContent = 'Connecting to API...';
    // Perform a health check on the backend
    const healthResponse = await fetch(API_CONFIG.baseUrl + API_CONFIG.endpoints.health);
    const healthData = await healthResponse.json();
    if (!healthData || healthData.status !== 'ok') {
      throw new Error('API health check failed');
    }
    // Fetch the list of countries
    if (statusText) statusText.textContent = 'Loading countries...';
    const countriesResponse = await fetch(API_CONFIG.baseUrl + API_CONFIG.endpoints.countries, {
      headers: { 'x-api-key': API_CONFIG.apiKey }
    });
    if (!countriesResponse.ok) {
      throw new Error('Failed to load countries');
    }
    const countriesData = await countriesResponse.json();
    countriesList = Array.isArray(countriesData.countries) ? countriesData.countries : [];
    countryNameMap = {};
    countriesList.forEach(c => {
      if (c && c.code !== undefined) {
        countryNameMap[c.code] = c.name;
      }
    });
    // Fetch the unit mappings
    if (statusText) statusText.textContent = 'Loading units...';
    const unitsResponse = await fetch(API_CONFIG.baseUrl + API_CONFIG.endpoints.units, {
      headers: { 'x-api-key': API_CONFIG.apiKey }
    });
    if (!unitsResponse.ok) {
      throw new Error('Failed to load units');
    }
    unitNameMap = await unitsResponse.json();
    // Update connection state
    isApiConnected = true;
    if (statusEl) {
      statusEl.classList.remove('disconnected');
      statusEl.classList.add('connected');
    }
    if (statusText) statusText.textContent = 'API Connected ✔';
    // Populate the select with downloaded countries
    buildCountrySelect();
    console.log('API connection successful');
  } catch (error) {
    console.error('API Connection Failed:', error);
    if (statusEl) {
      statusEl.classList.add('disconnected');
      statusEl.classList.remove('connected');
    }
    if (statusText) statusText.textContent = 'API Connection Failed ✗';
    alert('Failed to connect to backend API. Please refresh the page.');
  } finally {
    if (loadingEl) loadingEl.classList.remove('active');
  }
}
let useSecondUnit = true;
let useCustomsValue = false;
let startDate = ''; let endDate = '';
let originalRows = [];
let allSelectedHTSCodes = [];
let allSelectedCountries = [];
let activeHTSCodes = new Set();
let activeCountries = new Set();
let lastStartYear = null, lastEndYear = null, lastEndMonth = null;
let includeCombinedFlagForSlicer = false;
let currentPivot = null;
let currentTableRows = [];
let selectedCountriesList = [];

/* ---------- Helpers ---------- */
function formatNumber(val){
  if(typeof val!=='number'||isNaN(val)) return val;
  const abs = Math.abs(val);
  if(abs>=1000) return Math.round(val).toLocaleString(undefined,{maximumFractionDigits:0});
  return (Math.round(val*100)/100).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
}
function pctClass(p){
  if(!p||typeof p!=='string') return '';
  if(p.startsWith('-')) return 'pct-down';
  if(p.trim()==='') return '';
  return 'pct-up';
}

/* ---------- Populate countries (left) ---------- */
function buildCountrySelect(){
  const sel = document.getElementById('countrySelect');
  sel.innerHTML = '';
  // Always include two meta options at the top that allow selecting all countries
  [
    { code: 'ALL_COMBINED', name: 'All Countries (Combined)' },
    { code: 'ALL_SEPARATE', name: 'All Countries (Separate)' }
  ].forEach(e => {
    const opt = document.createElement('option');
    opt.value = e.code;
    opt.textContent = e.name;
    sel.appendChild(opt);
  });
  // Populate the select with countries returned from the backend
  countriesList.forEach(e => {
    const opt = document.createElement('option');
    opt.value = e.code;
    opt.textContent = e.name;
    sel.appendChild(opt);
  });
  renderActiveTags();
}

function renderActiveTags(){
  const tagWrap = document.getElementById('activeTags');
  tagWrap.innerHTML = '';
  
  selectedCountriesList.forEach(sel => {
    if (sel.code === 'ALL_COMBINED' || sel.code === 'ALL_SEPARATE') {
      const tag = document.createElement('span');
      tag.className = 'filter-tag';
      if (sel.code === 'ALL_SEPARATE') {
        tag.textContent = 'All Countries (Separate)';
      } else if (sel.code === 'ALL_COMBINED') {
        tag.textContent = 'All Countries (Combined)';
      } else {
        tag.textContent = sel.name.replace(/\s*\(.*\)/, '');
      }
      tagWrap.appendChild(tag);
    }
  });
  
  selectedCountriesList.forEach(sel => {
    if (sel.code === 'ALL_COMBINED' || sel.code === 'ALL_SEPARATE') return;
    const tag = document.createElement('span');
    tag.className = 'filter-tag';
    tag.textContent = sel.name.replace(/\s*\(.*\)/, '');
    tagWrap.appendChild(tag);
  });
  
  allSelectedHTSCodes.forEach(code => {
    const tag = document.createElement('span');
    tag.className = 'filter-tag';
    tag.textContent = 'HTS: ' + code;
    tagWrap.appendChild(tag);
  });
}

/* ---------- Search highlight + add behavior ---------- */
document.getElementById('countrySearch').addEventListener('input',()=>{
  const term = document.getElementById('countrySearch').value.toLowerCase().trim();
  const sel = document.getElementById('countrySelect');
  Array.from(sel.options).forEach(o=>o.selected=false);
  if(!term) return;
  for(const opt of Array.from(sel.options)){
    if(opt.textContent.toLowerCase().includes(term)){
      opt.selected=true; sel.value=opt.value;
      if(typeof opt.scrollIntoView==='function'){opt.scrollIntoView({block:'nearest'});} else { sel.scrollTop=opt.offsetTop; }
      break;
    }
  }
});

document.getElementById('addCountryBtn').addEventListener('click',()=>{
  const sel = document.getElementById('countrySelect');
  const search = document.getElementById('countrySearch').value.trim();
  
  if(search && search.includes(',')){
    search.split(',').map(s=>s.trim()).filter(Boolean).forEach(nameFrag=>{
      const opt = Array.from(sel.options).find(o=>o.textContent.toLowerCase().includes(nameFrag.toLowerCase()));
      if(opt && opt.value && !selectedCountriesList.some(e=>e.code===opt.value)){
        selectedCountriesList.push({code:opt.value,name:opt.textContent});
      }
    });
  }
  
  Array.from(sel.options).filter(o=>o.selected&&o.value).forEach(opt=>{
    if(!selectedCountriesList.some(e=>e.code===opt.value)){
      selectedCountriesList.push({code:opt.value,name:opt.textContent});
    }
  });
  document.getElementById('countrySearch').value='';
  renderActiveTags(); renderPills(); updateActiveSetsFromPills(); updateSlicedViews();
});

document.getElementById('clearAllCountries').addEventListener('click',()=>{
  selectedCountriesList = []; renderActiveTags(); renderPills(); updateActiveSetsFromPills(); updateSlicedViews();
});

/* ---------- HTS add/remove ---------- */
document.getElementById('addHTSBtn').addEventListener('click',()=>{
  const raw = (document.getElementById('htsCodes').value||'').trim();
  if(!raw) return;
  raw.split(',').map(s=>s.trim()).filter(Boolean).forEach(code=>{
    if(!allSelectedHTSCodes.includes(code)) allSelectedHTSCodes.push(code);
  });
  document.getElementById('htsCodes').value='';
  renderActiveTags(); renderPills(); updateActiveSetsFromPills(); updateSlicedViews();
});

document.getElementById('removeHTSBtn').addEventListener('click',()=>{
  allSelectedHTSCodes = []; renderActiveTags(); renderPills(); updateActiveSetsFromPills(); updateSlicedViews();
});

/* ---------- Fetch data ---------- */
async function fetchData(){
  bumpApiCounterIfNoKey();

  // Stop any background animation when a fetch is initiated. Once real data
  // begins loading we no longer want the decorative canvas overlay.
  try { stopBackgroundAnimation(); } catch(_){ }
  // Hide all pivot sections until we know there is data to display. If the fetch
  // results in no data or invalid input, the animation will be restarted and
  // these sections will remain hidden.
  document.querySelectorAll('.pivot-card').forEach(el => { el.style.display = 'none'; });
  // Put the results area into placeholder mode so it has height for the animation
  const fetchWrap = document.getElementById('resultsWrap');
  if(fetchWrap) fetchWrap.classList.add('placeholder-state');

  // ---------- Auto-add typed HTS codes and countries on fetch ----------
  // If the user typed comma-separated HTS codes but did not press the "Add" button,
  // automatically add those codes to the global list and clear the input.
  const rawHTSInput = (document.getElementById('htsCodes').value || '').trim();
  if(rawHTSInput){
    rawHTSInput.split(',').map(s=>s.trim()).filter(Boolean).forEach(code => {
      if(!allSelectedHTSCodes.includes(code)) allSelectedHTSCodes.push(code);
    });
    document.getElementById('htsCodes').value = '';
    // Update UI to reflect newly added HTS codes
    renderActiveTags();
    renderPills();
    updateActiveSetsFromPills();
  }

  // If the user typed comma-separated country names in the search box without clicking
  // "Add Selected", attempt to match them to available options and add to the selected list.
  const rawCountryInput = (document.getElementById('countrySearch').value || '').trim();
  if(rawCountryInput){
    const sel = document.getElementById('countrySelect');
    rawCountryInput.split(',').map(s=>s.trim()).filter(Boolean).forEach(nameFrag => {
      const opt = Array.from(sel.options).find(o => o.textContent.toLowerCase().includes(nameFrag.toLowerCase()));
      if(opt && opt.value && !selectedCountriesList.some(e => e.code === opt.value)){
        selectedCountriesList.push({ code: opt.value, name: opt.textContent });
      }
    });
    document.getElementById('countrySearch').value = '';
    // Update UI to reflect newly added countries
    renderActiveTags();
    renderPills();
    updateActiveSetsFromPills();
  }

  // Use allSelectedHTSCodes if any have been selected or auto-added. Otherwise fall back to any typed codes.
  const codes = allSelectedHTSCodes.length ? allSelectedHTSCodes.slice() :
    (document.getElementById('htsCodes').value||'').split(',').map(s=>s.trim()).filter(Boolean);
  // Capture start and end months
  startDate = document.getElementById('startDate').value;
  endDate = document.getElementById('endDate').value;

  const countries = selectedCountriesList.filter(e=>e.code!=='ALL_COMBINED' && e.code!=='ALL_SEPARATE').map(e=>e.code);
  const includeCombined = true;

  const apiKey = (document.getElementById('apiKey').value||'').trim();
  const resultsDiv = document.getElementById('results');
  resultsDiv.textContent='Fetching data...';

  if(codes.length===0){
    resultsDiv.textContent='Please enter at least one HTS code.';
    // restart the background animation when there is invalid input
    initBackgroundAnimation();
    return;
  }
  if(!startDate || !endDate){
    resultsDiv.textContent='Please select both a start and end month.';
    initBackgroundAnimation();
    return;
  }
  if(startDate.replace('-','')>endDate.replace('-','')){
    resultsDiv.textContent='Start month must be earlier than end month.';
    initBackgroundAnimation();
    return;
  }

  const tableRows=[]; const combinedRows=[];
  function processItem(item,code){
    let isoDate=''; if(item['time']) isoDate=item['time']; else if(item['YEAR']&&item['MONTH']) isoDate=item['YEAR']+'-'+String(item['MONTH']).padStart(2,'0');
    if(!isoDate) return; if(isoDate<startDate || isoDate>endDate) return;
    const [y,m] = isoDate.split('-'); const displayDate=Number(m)+'/1/'+y;
    const cif=Number(item['CON_CIF_MO']); const duty=Number(item['CAL_DUT_MO']); const valueLDP=(isFinite(cif)?cif:0)+(isFinite(duty)?duty:0);
    const valueCustoms = Number(item['CON_VAL_MO']);
    const qty1=Number(item['CON_QY1_MO']); const qty2=Number(item['CON_QY2_MO']);
    const unitCode1=item['UNIT_QY1']; const unitCode2=item['UNIT_QY2'];
    const cc=item['CTY_CODE']; const cname=item['CTY_NAME'];
    let quantity = useSecondUnit?qty2:qty1;
    let unitCode = useSecondUnit?unitCode2:unitCode1;
    let value = useCustomsValue ? (isFinite(valueCustoms)?valueCustoms:0) : (isFinite(valueLDP)?valueLDP:0);
    return { isoDate:isoDate,date:displayDate, code:code, country:cc, countryName:cname,
      value:value, quantity:quantity, unitCode:unitCode,
      valueLDP:isFinite(valueLDP)?valueLDP:0, valueCustoms:isFinite(valueCustoms)?valueCustoms:0,
      quantity1:qty1, quantity2:qty2, unitCode1:unitCode1, unitCode2:unitCode2 };
  }

  for(const code of codes){
    const base='https://api.census.gov/data/timeseries/intltrade/imports/hs';
    const vars=['I_COMMODITY','CON_CIF_MO','CAL_DUT_MO','CON_VAL_MO','CON_QY1_MO','UNIT_QY1','CON_QY2_MO','UNIT_QY2','CTY_CODE','CTY_NAME','YEAR','MONTH'];
    const sParts=startDate.split('-'); const eParts=endDate.split('-');
    const rangeStart=sParts[0]+'-01'; const rangeEnd=eParts[0]+'-12';
    let query='get='+vars.join(',')+'&I_COMMODITY='+code+'&COMM_LVL=HS10&SUMMARY_LVL=DET'+'&time=from+'+rangeStart+'+to+'+rangeEnd;
    if(apiKey) query+='&key='+encodeURIComponent(apiKey);
    const url=base+'?'+query;
    try{
      const resp=await fetch(url); if(!resp.ok) throw new Error('Network error'); const json=await resp.json();
      if(Array.isArray(json) && json.length>=2){
        const headers=json[0];
        for(let i=1;i<json.length;i++){
          const row={}; headers.forEach((h,idx)=>row[h]=json[i][idx]);
          const totalRow = row['CTY_CODE']==='-' || (row['CTY_NAME']||'').toUpperCase().startsWith('TOTAL');
          const r=processItem(row,code); if(!r) continue;
          if(totalRow){ if(includeCombined){ combinedRows.push({...r,country:'ALL',countryName:'All Countries (Combined)'});} continue; }
          if(countries.length>0 && !countries.includes(row['CTY_CODE'])) continue;
          tableRows.push(r);
        }
      }
    }catch(e){ console.error('Fetch failed for',code,e); }
  }
  if(includeCombined && combinedRows.length>0){ tableRows.push(...combinedRows); }
  if(tableRows.length===0){
    resultsDiv.textContent='No results found. Please check inputs or API key.';
    // restart animation since there is no data
    initBackgroundAnimation();
    return;
  }

  tableRows.sort((a,b)=> a.isoDate.localeCompare(b.isoDate) || a.code.localeCompare(b.code) || (b.value-a.value));
  currentTableRows = tableRows; resultsDiv.textContent='';

  try{ const [sy,sm]=startDate.split('-'); const [ey,em]=endDate.split('-'); lastStartYear=parseInt(sy,10); lastEndYear=parseInt(ey,10); lastEndMonth=parseInt(em,10);}catch(_){}
  originalRows = tableRows.slice();
  allSelectedHTSCodes = codes.slice();
  allSelectedCountries = ['ALL',...countries];
  activeHTSCodes = new Set(allSelectedHTSCodes);
  activeCountries = new Set(allSelectedCountries.filter(c=>c!=='ALL'));
  includeCombinedFlagForSlicer = true;

  updateRowsBasedOnToggles();
  renderPills();
  // Show the results container and reveal the pivot sections now that data is available.
  const wrapDone = document.getElementById('resultsWrap');
  if(wrapDone) {
    wrapDone.style.display='block';
    wrapDone.classList.remove('placeholder-state');
  }
  // Restore pivot cards to full opacity and ensure they are visible.  Clearing
  // the opacity property removes the translucent effect applied during the
  // placeholder state.  Display the pivot cards so the real tables can be rendered.
  document.querySelectorAll('.pivot-card').forEach(el => {
    el.style.display = 'block';
    el.style.opacity = '';
  });
  document.getElementById('downloadBtn').disabled=false;
  document.getElementById('qaDownloadCSV').disabled=false;
}
document.getElementById('fetchBtn').addEventListener('click', fetchData);

/* ---------- Toggle handlers ---------- */
document.getElementById('unitToggle').addEventListener('change', (e)=>{
  useSecondUnit = (e.target.value==='2'); updateRowsBasedOnToggles();
});
document.getElementById('valueToggle').addEventListener('change', (e)=>{
  useCustomsValue = (e.target.value==='customs'); updateRowsBasedOnToggles();
});
function updateRowsBasedOnToggles(){
  if(!originalRows || !originalRows.length) return;
  originalRows.forEach(r=>{
    if(useSecondUnit){ r.quantity=r.quantity2; r.unitCode=r.unitCode2; } else { r.quantity=r.quantity1; r.unitCode=r.unitCode1; }
    r.value = useCustomsValue ? r.valueCustoms : r.valueLDP;
  });
  updateSlicedViews();
}

/* ---------- CSV (always qty1/qty2 + both values) ---------- */
function downloadCSV(){
  if(!currentTableRows || !currentTableRows.length) return;
  const header = [
    'Date',
    'HTS Code',
    'Country Code',
    'Country Name',
    'LDP Value (Dollars)',
    'Customs Value (Dollars)',
    'Quantity (1st unit)',
    'Quantity (2nd unit)',
    'Unit (Q1)',
    'Unit (Q2)'
  ];
  const rows = currentTableRows.map(r => {
    return [
      r.date,
      r.code,
      r.country,
      (r.countryName || '').replace(/,/g, ''),
      (r.valueLDP || 0),
      (r.valueCustoms || 0),
      (r.quantity1 || 0),
      (r.quantity2 || 0),
      (r.unitCode1 || ''),
      (r.unitCode2 || '')
    ].join(',');
  });
  const csvContent = '\ufeff' + header.join(',') + '\r\n' + rows.join('\r\n');
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'trade_data.csv';
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}
document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
document.getElementById('qaDownloadCSV').addEventListener('click', downloadCSV);

/* ---------- Build pivot summary (reused) ---------- */
function buildPivotSummary(rows, startYear, endYear, endMonth, includeCombinedFlag, ensureAllCountriesList){
  const pivotContainer = document.getElementById('pivotContainer'); if(!pivotContainer) return;
  // Validate against dynamically loaded countries
  const valid = new Set(countriesList.map(e => e.code));
  const filtered = rows.filter(row=>{
    if(includeCombinedFlag && (row.country==='ALL' || row.country==='-')) return true;
    return valid.has(row.country);
  });
  if(!filtered.length){ pivotContainer.innerHTML=''; return; }
  const pivot={}, yearsSet=new Set(), monthsByYear={};
  filtered.forEach(r=>{
    let name = (r.country==='ALL'||r.country==='-') ? 'All Countries (Combined)' : (countryNameMap[r.country] || r.countryName || r.country);
    name = name.replace(/\s*\(.*\)/,'').trim();
    const [ys,ms]=r.isoDate.split('-'); const y=parseInt(ys,10), m=parseInt(ms,10);
    yearsSet.add(y);
    if(!pivot[name]) pivot[name]={yearTotals:{},monthlyTotals:{}};
    const qty = r.quantity || 0;
    pivot[name].yearTotals[y] = (pivot[name].yearTotals[y]||0) + qty;
    if(!pivot[name].monthlyTotals[y]) pivot[name].monthlyTotals[y]={};
    pivot[name].monthlyTotals[y][m] = (pivot[name].monthlyTotals[y][m]||0) + qty;
    if(!monthsByYear[y] || m>monthsByYear[y]) monthsByYear[y]=m;
  });
  if (ensureAllCountriesList) {
    // Ensure every fetched country appears in the summary
    countriesList.forEach(e => {
      if (!e || e.code === 'ALL_COMBINED' || e.code === 'ALL_SEPARATE') return;
      const nm = (e.name || '').replace(/\s*\(.*\)/,'').trim();
      if (!pivot[nm]) {
        pivot[nm] = { yearTotals: {}, monthlyTotals: {} };
      }
    });
  }
  let years;
  if(Number.isInteger(startYear)&&Number.isInteger(endYear)&&startYear<=endYear){
    if(endYear-startYear+1>10) startYear = endYear-9;
    years=[]; for(let y=startYear;y<=endYear;y++) years.push(y);
  }else{
    years=Array.from(yearsSet).sort((a,b)=>a-b);
  }
  if(!years.length){ pivotContainer.innerHTML=''; return; }
  const lastYear=years[years.length-1]; const prevYear=years.length>1?years[years.length-2]:lastYear; const firstYear=years[0];
  const maxMonthRange = (Number.isInteger(endMonth)&&endMonth>=1&&endMonth<=12) ? endMonth : (monthsByYear[lastYear]||12);
  const isPartialLastYear = maxMonthRange<12; const singleYear = years.length===1;
  const monthNames=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const ytdLabel = maxMonthRange>1 ? ('Jan - '+monthNames[maxMonthRange-1]) : (monthNames[maxMonthRange-1]||'');

  const headerList=['Country']; const keyList=['country'];
  if(!isPartialLastYear){ years.forEach(y=>{ headerList.push(''+y); keyList.push(''+y); }); }
  else{
    if(!singleYear){ years.slice(0,-1).forEach(y=>{ headerList.push(''+y); keyList.push(''+y); }); }
  }
  if(isPartialLastYear){
    if(singleYear){
      headerList.push(`${lastYear} YTD<br><small>(${ytdLabel})</small>`);
      keyList.push(`YTD ${lastYear}`);
    }
    else{
      headerList.push(`${prevYear} YTD<br><small>(${ytdLabel})</small>`); keyList.push(`YTD ${prevYear}`);
      headerList.push(`${lastYear} YTD<br><small>(${ytdLabel})</small>`); keyList.push(`YTD ${lastYear}`);
      years.slice(0,-2).forEach((y,idx)=>{ const n=years[idx+1];
        headerList.push(`%&nbsp;Change<br><small>${y} to ${n}</small>`);
        keyList.push(`Change ${y}-${n}`);
      });
      const lastFull = years[years.length-2];
      headerList.push(`%&nbsp;Change<br><small>${firstYear} to ${lastFull}</small>`);
      keyList.push(`Change ${firstYear}-${lastFull}`);
      const prevShort = String(prevYear).slice(-2);
      const lastShort = String(lastYear).slice(-2);
      headerList.push(`%&nbsp;Change<br><small>${prevShort} to ${lastShort} YTD</small>`);
      keyList.push(`Change YTD ${prevYear}-${lastYear}`);
    }
  }else{
    if(!singleYear){
      years.slice(0,-1).forEach((y,idx)=>{ const n=years[idx+1];
        headerList.push(`%&nbsp;Change<br><small>${y} to ${n}</small>`);
        keyList.push(`Change ${y}-${n}`);
      });
      headerList.push(`%&nbsp;Change<br><small>${firstYear} to ${lastYear}</small>`);
      keyList.push(`Change ${firstYear}-${lastYear}`);
    }
  }

  const pivotRows=[];
  for(const c in pivot){
    const e={country:c};
    years.forEach(y=>{ e[y]=pivot[c].yearTotals[y]||0; });
    const sumYear=(yr)=>{ let t=0; const m = pivot[c].monthlyTotals[yr]||{}; for(let i=1;i<=maxMonthRange;i++){ if(m[i]) t+=m[i]; } return t; };
    e[`YTD ${prevYear}`]=sumYear(prevYear); e[`YTD ${lastYear}`]=sumYear(lastYear);
    years.slice(0,-1).forEach((y,idx)=>{ const n=years[idx+1]; const pv=e[y], nv=e[n]; e[`Change ${y}-${n}`]=(pv&&pv!==0)?(((nv-pv)/pv)*100).toFixed(2)+'%':''; });
    const lastFull = (maxMonthRange<12&&years.length>1)? years[years.length-2] : lastYear;
    const fv=e[firstYear], lv=e[lastFull]; e[`Change ${firstYear}-${lastFull}`]=(fv&&fv!==0)?(((lv-fv)/fv)*100).toFixed(2)+'%':'';
    const ymPrev=e[`YTD ${prevYear}`], ymLast=e[`YTD ${lastYear}`];
    e[`Change YTD ${prevYear}-${lastYear}`]=(ymPrev&&ymPrev!==0)?(((ymLast-ymPrev)/ymPrev)*100).toFixed(2)+'%':'';
    pivotRows.push(e);
  }
  pivotRows.sort((a,b)=>a.country.localeCompare(b.country));
  currentPivot={headerList,keyList,pivotRows:[]};

  let html='<table><thead><tr>';
  headerList.forEach((h,idx)=> html+=`<th style="text-align:${idx===0?'left':'center'}">${h}</th>`);
  html+='</tr></thead><tbody>';
  pivotRows.forEach(row=>{
    html+='<tr>'; keyList.forEach((k,idx)=>{
      let cell = (row[k]!==undefined&&row[k]!==null)? row[k] : '';
      if(typeof cell==='number') cell = formatNumber(cell);
      if(typeof cell==='string' && cell.includes('%')){
        const cls = pctClass(cell); cell = `<span class="${cls}">${cell}</span>`;
      }
      html+=`<td style="text-align:${idx===0?'left':'center'}">${cell}</td>`;
    });
    html+='</tr>';
    const csvRow={}; keyList.forEach(k=>csvRow[k]=row[k]||''); currentPivot.pivotRows.push(csvRow);
  });
  html+='</tbody></table>'; pivotContainer.innerHTML=html;
}

/* ---------- Negligibility ---------- */
function renderNegligibilityAnalysis(rows){
  const container=document.getElementById('negligibilityContainer'); if(!container) return;
  if(!rows||!rows.length){ container.innerHTML=''; return; }
  let maxIso=null; rows.forEach(r=>{ if(r&&r.isoDate){ if(!maxIso||r.isoDate>maxIso) maxIso=r.isoDate; } });
  if(!maxIso){ container.innerHTML=''; return; }
  const [yStr,mStr]=maxIso.split('-'); const maxYear=parseInt(yStr,10), maxMonth=parseInt(mStr,10);
  const maxNum=maxYear*12+maxMonth; const cutoff=maxNum-11;
  const startYear=Math.floor(cutoff/12); const startMonth=cutoff-startYear*12;
  const names=['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  const range = `${names[startMonth-1]} ${String(startYear).slice(-2)} - ${names[maxMonth-1]} ${String(maxYear).slice(-2)}`;
  // Build a set of valid country codes from the dynamically loaded list
  const valid = new Set(countriesList.map(e => e.code));
  // Compute totals for each country and for "All Countries" based on the active HTS universe.
  const totals = {};
  let combinedRowsTotal = 0;
  // Use the universe restricted to active HTS codes for computing overall totals
  const universe = rowsForActiveHTSUniverse(originalRows);
  universe.forEach(r => {
    if(!r || !r.isoDate) return;
    const [ys, ms] = r.isoDate.split('-');
    const y = parseInt(ys, 10), m = parseInt(ms, 10);
    const num = y*12 + m;
    if(num < cutoff) return;
    const qty = r.quantity || 0;
    const code = r.country;
    if(code === 'ALL' || code === '-') {
      combinedRowsTotal += qty;
    } else if(valid.has(code)) {
      totals[code] = (totals[code] || 0) + qty;
    }
  });
  // Derive totalAll from combined rows when available; otherwise sum per-country totals
  let totalAll = combinedRowsTotal > 0
    ? combinedRowsTotal
    : Object.values(totals).reduce((a, v) => a + v, 0);
  // Determine which per‑country rows should be shown in the negligibility table. If
  // some countries have been selected but none are currently active, omit the
  // individual country rows and show only the aggregate "All Countries" row.
  let codesToShow;
  if(Array.isArray(selectedCountriesList) && selectedCountriesList.length){
    if(activeCountries && activeCountries.size === 0){
      // Countries are selected but all pills are toggled off -> hide per‑country rows
      codesToShow = [];
    } else {
      codesToShow = selectedCountriesList
        .filter(e=>e.code!=='ALL_COMBINED')
        .map(e=>e.code);
    }
  } else {
    codesToShow = Object.keys(totals);
  }

  let html='<table><thead><tr><th style="text-align:left">Country</th>';
  html+=`<th style="text-align:right">Quantity (12 months: ${range})</th><th style="text-align:right">Share (12 months: ${range})</th></tr></thead><tbody>`;
  html+=`<tr><td style="text-align:left">All Countries</td><td style="text-align:right">${formatNumber(totalAll)}</td><td style="text-align:right">100%</td></tr>`;
  codesToShow.forEach(code=>{
    const qty=totals[code]||0; const share= totalAll? ((qty/totalAll)*100).toFixed(2)+'%' : '';
    let name = (countryNameMap[code]||code).replace(/\s*\(.*\)/,'').trim();
    html+=`<tr><td style="text-align:left">${name}</td><td style="text-align:right">${formatNumber(qty)}</td><td style="text-align:right">${share}</td></tr>`;
  });
  html+='</tbody></table>'; container.innerHTML=html;
}

/* ---------- Transform/Filter and Sliced Views ---------- */
function transformRows(){
  // Return a transformed copy of the original rows based on the current country
  // and HTS code filters. This version distinguishes between "nothing selected"
  // and "everything toggled off" by looking at the full list of selected
  // countries/codes rather than just the active sets. When a filter is
  // engaged (at least one item has been selected) but no items are currently
  // active, the corresponding rows are zeroed out rather than being treated as
  // unfiltered. Synthetic "All Countries" rows ignore the country filter but
  // still respect the HTS code filter.
  if(!originalRows || !originalRows.length) return [];
  const out = [];
  // Determine whether anything has been selected in each dimension
  const codesSelected = Array.isArray(allSelectedHTSCodes) && allSelectedHTSCodes.length > 0;
  const countriesSelected = Array.isArray(selectedCountriesList) && selectedCountriesList.length > 0;
  originalRows.forEach(r => {
    const isSynthetic = (r.country === 'ALL' || r.country === '-');
    // Determine if this row passes the country and code filters. When nothing
    // has been selected, the filter is treated as not engaged, so all rows
    // pass. When a filter is engaged but no items are active, every row that
    // isn't synthetic fails the check and will be zeroed out. When items are
    // both selected and some are active, only active items pass.
    const includeByCountry = (!countriesSelected) || isSynthetic || activeCountries.has(r.country);
    const includeByCode    = (!codesSelected) || activeHTSCodes.has(r.code);
    if(isSynthetic){
      // Synthetic rows respect only the HTS code filter
      if(includeByCode){
        out.push({ ...r });
      } else {
        const nr = { ...r, quantity: 0 };
        if(typeof nr.value !== 'undefined') nr.value = 0;
        out.push(nr);
      }
    } else {
      if(includeByCountry && includeByCode){
        // Row passes all engaged filters
        out.push({ ...r });
      } else {
        // Row fails at least one engaged filter; retain structure but zero out values
        const nr = { ...r, quantity: 0 };
        if(typeof nr.value !== 'undefined') nr.value = 0;
        out.push(nr);
      }
    }
  });
  return out;
}

// Helper to obtain a filtered copy of the original rows restricted to the active HTS universe.
// The universe is defined solely by active HTS codes, ignoring any country filters.
// When no HTS filters are active, this returns a shallow copy of the original array.
function rowsForActiveHTSUniverse(baseRows = originalRows) {
  // Return a copy of the provided rows restricted to the active HTS code
  // universe. This helper distinguishes between "no codes selected" (no
  // filtering), "codes selected but none active" (filter engaged but
  // everything toggled off, so the universe is empty) and "codes selected
  // with some active" (include only active codes). It ignores the country
  // filter entirely.
  if(!baseRows || !baseRows.length) return [];
  const codesSelected = Array.isArray(allSelectedHTSCodes) && allSelectedHTSCodes.length > 0;
  const codesActive = activeHTSCodes && activeHTSCodes.size > 0;
  if(!codesSelected){
    // No HTS codes have been selected at all -> no filtering
    return baseRows.slice();
  }
  if(!codesActive){
    // Codes have been selected but none are currently active -> the universe is empty
    return [];
  }
  // Codes are both selected and some are active -> include only rows whose code is active
  return baseRows.filter(r => r && activeHTSCodes.has(r.code));
}

function updateSlicedViews(){
  if(!originalRows||!originalRows.length) return;
  const pivotContainer=document.getElementById('pivotContainer');
  const negContainer=document.getElementById('negligibilityContainer');
  const slicedPivot=document.getElementById('slicedPivotContainer');
  const slicedPivotVal=document.getElementById('slicedPivotValueContainer');
  const slicedPivotAvg=document.getElementById('slicedPivotAvgContainer');
  const slicedNeg=document.getElementById('slicedNegligibilityContainer');

  const rows = transformRows();

  if(Array.isArray(selectedCountriesList) && selectedCountriesList.length){
    const codesToCheck = selectedCountriesList
      .filter(e=> e.code !== 'ALL_COMBINED' && e.code !== 'ALL_SEPARATE')
      .map(e=> e.code);
    codesToCheck.forEach(code => {
      const exists = rows.some(r => r.country === code);
      if(!exists){
        let isoYear = (typeof lastStartYear === 'number' && !isNaN(lastStartYear)) ? lastStartYear : (new Date().getFullYear());
        let isoMonth = (typeof lastEndMonth === 'number' && !isNaN(lastEndMonth)) ? lastEndMonth : (new Date().getMonth()+1);
        const iso = `${isoYear}-${String(isoMonth).padStart(2,'0')}`;
        rows.push({
          isoDate: iso,
          date: '',
          code: '',
          country: code,
          countryName: '',
          value: 0,
          quantity: 0,
          unitCode: '',
          valueLDP: 0,
          valueCustoms: 0,
          quantity1: 0,
          quantity2: 0,
          unitCode1: '',
          unitCode2: ''
        });
      }
    });
  }

  const ensureAll = (selectedCountriesList.length === 0) || selectedCountriesList.some(e=>e.code==='ALL_SEPARATE');

  // Quantity pivot
  buildPivotSummary(rows, lastStartYear, lastEndYear, lastEndMonth, false, ensureAll);
  const pivotDataQty = JSON.parse(JSON.stringify(currentPivot));
  let qtyHTML = pivotContainer.innerHTML;

  const units = new Set(); rows.forEach(r=>{ if(r&&r.unitCode && r.country!=='ALL' && r.country!=='-'){ const code=(r.unitCode||'').toString().toUpperCase().trim(); if(code) units.add(unitNameMap[code]||code); } });
  const unitLabel = units.size? ' ('+Array.from(units).join(', ')+')':'';
  document.getElementById('qtyTitle').textContent = 'Quantity'+unitLabel;

  // Append Subject/Nonsubject/Total to qty table
  try{
    const klist = pivotDataQty.keyList;
    const aggs={}; klist.forEach(k=>aggs[k]=0);
    pivotDataQty.pivotRows.forEach(r=>{
      const nm=(r.country||'').toString().toLowerCase();
      if(nm==='all countries'||nm==='all countries (combined)'||nm==='all countries combined') return;
      klist.forEach(k=>{ if(k==='country') return; const v=r[k]; if(typeof v==='number') aggs[k]+=v; else if(v!==''&&!isNaN(v)) aggs[k]+=Number(v); });
    });
    const pct={}; klist.forEach(k=>{
      if(k!=='country' && k.startsWith('Change ')){
        if(k.includes('YTD')){ const p=k.split(' ')[2].split('-'); const a=aggs['YTD '+p[0]]||0, b=aggs['YTD '+p[1]]||0; pct[k]=(a?(((b-a)/a)*100).toFixed(2)+'%':''); }
        else { const parts=k.replace('Change ','').split('-'); const a=aggs[parts[0]]||0, b=aggs[parts[1]]||0; pct[k]=(a?(((b-a)/a)*100).toFixed(2)+'%':''); }
      }
    });
    const tmp=document.createElement('div'); tmp.innerHTML=qtyHTML;
    const tbody=tmp.querySelector('tbody');
    const renderRow=(label,vals,perc)=>{
      const tr=document.createElement('tr'); tr.className='summary-row';
      klist.forEach((k,idx)=>{
        const td=document.createElement('td'); td.style.textAlign = idx===0?'left':'center';
        if(k==='country'){ td.textContent=label; }
        else if(k.startsWith('Change ')){ const p=perc[k]||''; td.innerHTML = p? `<span class="${pctClass(p)}">${p}</span>`:''; }
        else { td.textContent = formatNumber(vals[k]||0); }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    };
    // Rebuild totals from the active HTS universe, ignoring country filters
    const universeRowsQtyAll = rowsForActiveHTSUniverse(originalRows);
    buildPivotSummary(universeRowsQtyAll, lastStartYear, lastEndYear, lastEndMonth, true, ensureAll);
    const allRow = (currentPivot.pivotRows||[]).find(r=>{
      const n=(r.country||'').toString().toLowerCase();
      return n==='all countries'||n==='all countries (combined)'||n==='all countries combined';
    }) || {};
    const allTotals={}; klist.forEach(k=>{ if(k==='country'||k.startsWith('Change ')) return; allTotals[k] = typeof allRow[k]==='number' ? allRow[k] : (isNaN(parseFloat((allRow[k]||'').toString().replace(/,/g,'')))?0:parseFloat((allRow[k]||'').toString().replace(/,/g,''))); });
    const nonTotals={}; klist.forEach(k=>{ if(k==='country'||k.startsWith('Change ')) return; nonTotals[k]=(allTotals[k]||0)-(aggs[k]||0); });

    const pctNon={}; klist.forEach(k=>{
      if(k!=='country' && k.startsWith('Change ')){
        let prevKey,currKey;
        if(k.includes('YTD')){ const pr=k.split(' ')[2].split('-'); prevKey='YTD '+pr[0]; currKey='YTD '+pr[1]; }
        else { const parts=k.replace('Change ','').split('-'); prevKey=parts[0]; currKey=parts[1]; }
        const a=nonTotals[prevKey]||0, b=nonTotals[currKey]||0; pctNon[k]=(a?(((b-a)/a)*100).toFixed(2)+'%':''); 
      }
    });
    const pctAll={}; klist.forEach(k=>{
      if(k!=='country' && k.startsWith('Change ')){
        let prevKey,currKey;
        if(k.includes('YTD')){ const pr=k.split(' ')[2].split('-'); prevKey='YTD '+pr[0]; currKey='YTD '+pr[1]; }
        else { const parts=k.replace('Change ','').split('-'); prevKey=parts[0]; currKey=parts[1]; }
        const a=allTotals[prevKey]||0, b=allTotals[currKey]||0; pctAll[k]=(a?(((b-a)/a)*100).toFixed(2)+'%':''); 
      }
    });
    renderRow('Subject Imports', aggs, pct);
    renderRow('Nonsubject Imports', nonTotals, pctNon);
    renderRow('Total Imports', allTotals, pctAll);
    Array.from(tmp.querySelectorAll('tbody tr')).forEach(tr=>{
      const first=tr.querySelector('td'); if(!first) return;
      const name=first.textContent.trim().replace(/\s*\(.*\)/,'').toLowerCase();
      if(name==='all countries'||name==='all countries combined') tr.remove();
    });
    qtyHTML=tmp.innerHTML;
  }catch(e){}
  slicedPivot.innerHTML=qtyHTML;

  // Value pivot
  const rowsVal = rows.map(r=>{ const n={...r}; n.quantity = (typeof r.value!=='undefined'&&r.value!==null)? r.value:0; return n; });
  buildPivotSummary(rowsVal, lastStartYear, lastEndYear, lastEndMonth, false, ensureAll);
  const pivotDataVal = JSON.parse(JSON.stringify(currentPivot));
  let valHTML=pivotContainer.innerHTML;
  document.getElementById('valTitle').textContent = (useCustomsValue?'Customs Value (Dollars)':'LDP Value (Dollars)');
  
  // Append summary rows (Subject/Non/Total) with $ formatting
  try{
    const klist=pivotDataVal.keyList;
    const aggs={}; klist.forEach(k=>aggs[k]=0);
    pivotDataVal.pivotRows.forEach(r=>{
      const nm=(r.country||'').toString().toLowerCase(); if(nm==='all countries'||nm==='all countries (combined)'||nm==='all countries combined') return;
      klist.forEach(k=>{ if(k==='country') return; const v=r[k]; if(typeof v==='number') aggs[k]+=v; else if(v!==''&&!isNaN(v)) aggs[k]+=Number(v); });
    });
    const pct={}; klist.forEach(k=>{
      if(k!=='country' && k.startsWith('Change ')){
        if(k.includes('YTD')){ const p=k.split(' ')[2].split('-'); const a=aggs['YTD '+p[0]]||0, b=aggs['YTD '+p[1]]||0; pct[k]=(a?(((b-a)/a)*100).toFixed(2)+'%':''); }
        else { const parts=k.replace('Change ','').split('-'); const a=aggs[parts[0]]||0, b=aggs[parts[1]]||0; pct[k]=(a?(((b-a)/a)*100).toFixed(2)+'%':''); }
      }
    });
    const tmp=document.createElement('div'); tmp.innerHTML=valHTML;
    const tbody=tmp.querySelector('tbody');
    const renderRow=(label,vals,percs)=>{
      const tr=document.createElement('tr'); tr.className='summary-row';
      klist.forEach((k,idx)=>{
        const td=document.createElement('td'); td.style.textAlign = idx===0?'left':'center';
        if(k==='country'){ td.textContent=label; }
        else if(k.startsWith('Change ')){ const p=percs[k]||''; td.innerHTML = p? `<span class="${pctClass(p)}">${p}</span>`:''; }
        else { td.textContent = '$'+formatNumber(vals[k]||0); }
        tr.appendChild(td);
      });
      tbody.appendChild(tr);
    };
    // Build totals from the active HTS universe for value pivot
    const rowsValAllUniverse = rowsForActiveHTSUniverse(originalRows)
      .map(r => { const n={...r}; n.quantity = (typeof r.value !== 'undefined' && r.value !== null) ? r.value : 0; return n; });
    buildPivotSummary(rowsValAllUniverse, lastStartYear, lastEndYear, lastEndMonth, true, ensureAll);
    const allRow = (currentPivot.pivotRows||[]).find(r=>{ const n=(r.country||'').toString().toLowerCase(); return n==='all countries'||n==='all countries (combined)'||n==='all countries combined'; })||{};
    const allTotals={}; klist.forEach(k=>{ if(k==='country'||k.startsWith('Change ')) return; allTotals[k]= typeof allRow[k]==='number'? allRow[k] : (isNaN(parseFloat((allRow[k]||'').toString().replace(/,/g,'')))?0:parseFloat((allRow[k]||'').toString().replace(/,/g,''))); });
    const nonTotals={}; klist.forEach(k=>{ if(k==='country'||k.startsWith('Change ')) return; nonTotals[k]=(allTotals[k]||0)-(aggs[k]||0); });
    const pctNon={}, pctAll={};
    klist.forEach(k=>{
      if(k!=='country' && k.startsWith('Change ')){
        let prevKey,currKey;
        if(k.includes('YTD')){ const pr=k.split(' ')[2].split('-'); prevKey='YTD '+pr[0]; currKey='YTD '+pr[1]; }
        else { const parts=k.replace('Change ','').split('-'); prevKey=parts[0]; currKey=parts[1]; }
        const aN=nonTotals[prevKey]||0, bN=nonTotals[currKey]||0; pctNon[k]=(aN?(((bN-aN)/aN)*100).toFixed(2)+'%':''); 
        const aA=allTotals[prevKey]||0, bA=allTotals[currKey]||0; pctAll[k]=(aA?(((bA-aA)/aA)*100).toFixed(2)+'%':''); 
      }
    });
    renderRow('Subject Imports', aggs, pct);
    renderRow('Nonsubject Imports', nonTotals, pctNon);
    renderRow('Total Imports', allTotals, pctAll);
    Array.from(tmp.querySelectorAll('tbody tr')).forEach(tr=>{
      const first=tr.querySelector('td'); if(!first) return;
      const valTds=Array.from(tr.querySelectorAll('td')).slice(1).filter(td=>!td.textContent.includes('%'));
      valTds.forEach(td=>{ if(td.textContent && !td.textContent.startsWith('$')) td.textContent = '$'+td.textContent; });
      const name=first.textContent.trim().replace(/\s*\(.*\)/,'').toLowerCase(); if(name==='all countries'||name==='all countries combined') tr.remove();
    });
    valHTML=tmp.innerHTML;
  }catch(e){}
  slicedPivotVal.innerHTML=valHTML;

  // AUV pivot
  const rowsAvg = rows.map(r=>{ const n={...r}; const q=(r.quantity&&r.quantity!==0)?r.quantity:0; const v=(typeof r.value!=='undefined'&&r.value!==null)?r.value:0; n.quantity = q? (v/q) : 0; return n; });
  buildPivotSummary(rowsAvg, lastStartYear, lastEndYear, lastEndMonth, false, ensureAll);
  const pivotDataAvg = JSON.parse(JSON.stringify(currentPivot));
  let auvHTML = pivotContainer.innerHTML;
  try{
    const tmp=document.createElement('div'); tmp.innerHTML=auvHTML;
    const titleEl = document.getElementById('qtyTitle');
    const qtyTxt = titleEl ? titleEl.textContent : 'Quantity';
    let unitTxt = '';
    if(qtyTxt.includes('(')){
      unitTxt = qtyTxt.slice(qtyTxt.indexOf('(')+1, qtyTxt.indexOf(')'));
    }
    const avgTitle = document.getElementById('avgTitle');
    if(avgTitle){ avgTitle.textContent = 'Average Unit Value ' + (unitTxt?`(Dollars/${unitTxt.replace(/s$/,'')})`:'(Dollars/Unit)'); }
    
    (function(){
      const qtyRows = pivotDataQty && pivotDataQty.pivotRows ? pivotDataQty.pivotRows : [];
      const valRows = pivotDataVal && pivotDataVal.pivotRows ? pivotDataVal.pivotRows : [];
      const klistLocal = pivotDataAvg && pivotDataAvg.keyList ? pivotDataAvg.keyList : [];
      const tbodyRows = tmp.querySelectorAll('tbody tr');
      for(let i=0; i < pivotDataAvg.pivotRows.length; i++){
        const row = pivotDataAvg.pivotRows[i];
        const qtyRow = qtyRows[i] || {};
        const valRow = valRows[i] || {};
        const cells = tbodyRows[i] ? tbodyRows[i].querySelectorAll('td') : [];
        klistLocal.forEach((k, idx) => {
          if(k === 'country' || k.startsWith('Change ')) return;
          const q = qtyRow[k] || 0;
          const v = valRow[k] || 0;
          const ratioVal = (q && q !== 0) ? v / q : 0;
          row[k] = ratioVal;
          if(cells[idx]){
            cells[idx].textContent = '$' + formatNumber(ratioVal);
          }
        });
      }
      for(let i=0; i < pivotDataAvg.pivotRows.length; i++){
        const row = pivotDataAvg.pivotRows[i];
        const cells = tbodyRows[i] ? tbodyRows[i].querySelectorAll('td') : [];
        klistLocal.forEach((k, idx) => {
          if(k.startsWith('Change ')){
            let prevKey, currKey;
            if(k.includes('YTD')){
              const pr = k.split(' ')[2].split('-');
              prevKey = 'YTD ' + pr[0]; currKey = 'YTD ' + pr[1];
            } else {
              const parts = k.replace('Change ','').split('-');
              prevKey = parts[0]; currKey = parts[1];
            }
            const a = row[prevKey] || 0;
            const b = row[currKey] || 0;
            const pctVal = (a && a !== 0) ? (((b - a) / a) * 100).toFixed(2) + '%' : '';
            row[k] = pctVal;
            if(cells[idx]){
              cells[idx].innerHTML = pctVal ? `<span class="${pctClass(pctVal)}">${pctVal}</span>` : '';
            }
          }
        });
      }
    })();
    
    // Build Subject, Nonsubject and Total summary rows
    try {
      const klist = pivotDataAvg.keyList || [];
      // Initialize accumulators for subject (aggs) and overall totals
      const aggsVal = {};
      const aggsQty = {};
      const allTotalsVal = {};
      const allTotalsQty = {};
      klist.forEach(k => {
        if(k === 'country' || k.startsWith('Change ')) return;
        aggsVal[k] = 0;
        aggsQty[k] = 0;
        allTotalsVal[k] = 0;
        allTotalsQty[k] = 0;
      });
      // Sum values and quantities across each row of the value and quantity pivots.
      // The "aggs" sums exclude the synthetic "all countries" rows so that
      // subject and nonsubject calculations are based on actual country data.
      (pivotDataVal.pivotRows || []).forEach(r => {
        const nm = (r.country || '').toString().toLowerCase();
        klist.forEach(k => {
          if(k === 'country' || k.startsWith('Change ')) return;
          const vVal = r[k];
          let numVal = 0;
          if(typeof vVal === 'number') numVal = vVal;
          else if(vVal !== '' && !isNaN(vVal)) numVal = Number(vVal);
          allTotalsVal[k] += numVal;
          if(nm !== 'all countries' && nm !== 'all countries (combined)' && nm !== 'all countries combined'){
            aggsVal[k] += numVal;
          }
        });
      });
      (pivotDataQty.pivotRows || []).forEach(r => {
        const nm = (r.country || '').toString().toLowerCase();
        klist.forEach(k => {
          if(k === 'country' || k.startsWith('Change ')) return;
          const vQty = r[k];
          let numQty = 0;
          if(typeof vQty === 'number') numQty = vQty;
          else if(vQty !== '' && !isNaN(vQty)) numQty = Number(vQty);
          allTotalsQty[k] += numQty;
          if(nm !== 'all countries' && nm !== 'all countries (combined)' && nm !== 'all countries combined'){
            aggsQty[k] += numQty;
          }
        });
      });
      // Compute nonsubject totals by subtracting the subject totals from the overall totals
      // --- Override: compute true TOTALS from full dataset (All Countries (Combined)) ---
      const __toNum = (x) => (typeof x === 'number') ? x : (isNaN(parseFloat((x||'').toString().replace(/,/g,''))) ? 0 : parseFloat((x||'').toString().replace(/,/g,'')));

      try {
        // Value totals (respecting LDP/Customs toggle): restrict to active HTS universe and map value -> quantity
        const rowsValAllUniverseAUV = rowsForActiveHTSUniverse(originalRows)
          .map(r => { const n = { ...r }; n.quantity = (typeof r.value !== 'undefined' && r.value !== null) ? r.value : 0; return n; });
        buildPivotSummary(rowsValAllUniverseAUV, lastStartYear, lastEndYear, lastEndMonth, true, ensureAll);
        const allRowVal_fix = (currentPivot.pivotRows || []).find(r => {
          const nm = (r.country || '').toString().toLowerCase();
          return nm === 'all countries' || nm === 'all countries (combined)' || nm === 'all countries combined';
        }) || {};
        klist.forEach(k => { if(k === 'country' || k.startsWith('Change ')) return; allTotalsVal[k] = __toNum(allRowVal_fix[k]); });

        // Quantity totals (respecting 1st/2nd unit toggle): restrict to active HTS universe
        const rowsQtyAllUniverseAUV = rowsForActiveHTSUniverse(originalRows);
        buildPivotSummary(rowsQtyAllUniverseAUV, lastStartYear, lastEndYear, lastEndMonth, true, ensureAll);
        const allRowQty_fix = (currentPivot.pivotRows || []).find(r => {
          const nm = (r.country || '').toString().toLowerCase();
          return nm === 'all countries' || nm === 'all countries (combined)' || nm === 'all countries combined';
        }) || {};
        klist.forEach(k => { if(k === 'country' || k.startsWith('Change ')) return; allTotalsQty[k] = __toNum(allRowQty_fix[k]); });
      } catch(__e) { /* swallow */ }
      // --- End override ---
    
      const nonTotalsVal = {};
      const nonTotalsQty = {};
      klist.forEach(k => {
        if(k === 'country' || k.startsWith('Change ')) return;
        nonTotalsVal[k] = (allTotalsVal[k] || 0) - (aggsVal[k] || 0);
        nonTotalsQty[k] = (allTotalsQty[k] || 0) - (aggsQty[k] || 0);
      });
      // Compute average unit value ratios for subject, nonsubject and total imports
      const aggsRatio = {};
      const nonTotalsRatio = {};
      const allTotalsRatio = {};
      klist.forEach(k => {
        if(k === 'country' || k.startsWith('Change ')) return;
        aggsRatio[k] = (aggsQty[k] !== 0 ? aggsVal[k] / aggsQty[k] : 0);
        nonTotalsRatio[k] = (nonTotalsQty[k] !== 0 ? nonTotalsVal[k] / nonTotalsQty[k] : 0);
        allTotalsRatio[k] = (allTotalsQty[k] !== 0 ? allTotalsVal[k] / allTotalsQty[k] : 0);
      });
      // Compute percent change columns for each category by comparing ratios between periods
      const pctSubject = {}, pctNon = {}, pctAll = {};
      klist.forEach(k => {
        if(k !== 'country' && k.startsWith('Change ')){
          let prevKey, currKey;
          if(k.includes('YTD')){
            const pr = k.split(' ')[2].split('-');
            prevKey = 'YTD ' + pr[0]; currKey = 'YTD ' + pr[1];
          } else {
            const parts = k.replace('Change ','').split('-');
            prevKey = parts[0]; currKey = parts[1];
          }
          const aS = aggsRatio[prevKey] || 0; const bS = aggsRatio[currKey] || 0;
          pctSubject[k] = (aS ? (((bS - aS) / aS) * 100).toFixed(2) + '%' : '');
          const aN = nonTotalsRatio[prevKey] || 0; const bN = nonTotalsRatio[currKey] || 0;
          pctNon[k] = (aN ? (((bN - aN) / aN) * 100).toFixed(2) + '%' : '');
          const aA = allTotalsRatio[prevKey] || 0; const bA = allTotalsRatio[currKey] || 0;
          pctAll[k] = (aA ? (((bA - aA) / aA) * 100).toFixed(2) + '%' : '');
        }
      });
      // Append summary rows to the AUV pivot
      const tbodyAUV = tmp.querySelector('tbody');
      const renderRowAUV = (label, vals, percs) => {
        const tr = document.createElement('tr');
        tr.className = 'summary-row';
        klist.forEach((k, idx) => {
          const td = document.createElement('td');
          td.style.textAlign = idx === 0 ? 'left' : 'center';
          if(k === 'country'){
            td.textContent = label;
          } else if(k.startsWith('Change ')){
            const pVal = percs[k] || '';
            td.innerHTML = pVal ? `<span class="${pctClass(pVal)}">${pVal}</span>` : '';
          } else {
            td.textContent = '$' + formatNumber(vals[k] || 0);
          }
          tr.appendChild(td);
        });
        tbodyAUV.appendChild(tr);
      };
      renderRowAUV('Subject Imports', aggsRatio, pctSubject);
      renderRowAUV('Nonsubject Imports', nonTotalsRatio, pctNon);
      renderRowAUV('Total Imports', allTotalsRatio, pctAll);
    } catch(_err) { /* ignore errors in summary generation */ }
    
    Array.from(tmp.querySelectorAll('tbody tr')).forEach(tr=>{
      const first=tr.querySelector('td'); if(!first) return;
      const valTds=Array.from(tr.querySelectorAll('td')).slice(1).filter(td=>!td.textContent.includes('%'));
      valTds.forEach(td=>{ if(td.textContent && !td.textContent.startsWith('$')) td.textContent = '$'+td.textContent; });
      const name=first.textContent.trim().replace(/\s*\(.*\)/,'').toLowerCase(); if(name==='all countries'||name==='all countries combined') tr.remove();
    });
    auvHTML = tmp.innerHTML;
  }catch(e){}
  slicedPivotAvg.innerHTML=auvHTML;
  pivotContainer.innerHTML='';

  renderNegligibilityAnalysis(rows);
  slicedNeg.innerHTML = negContainer.innerHTML;
  negContainer.innerHTML='';
}

/* ---------- Dynamic pill slicers (right panel) ---------- */
function renderPills(){
  const pillC=document.getElementById('pillCountries'); const pillH=document.getElementById('pillHts');
  pillC.innerHTML=''; pillH.innerHTML='';
  allSelectedCountries = ['ALL', ...selectedCountriesList.filter(e=>e.code!=='ALL_COMBINED' && e.code!=='ALL_SEPARATE').map(e=>e.code)];
  selectedCountriesList.forEach(e=>{
    if(e.code==='ALL_COMBINED' || e.code==='ALL_SEPARATE') return;
    const div=document.createElement('div'); div.className='pill active'; div.dataset.value=e.code;
    div.innerHTML='<span class="dot"></span>'+ (e.name.replace(/\s*\(.*\)/,'').trim());
    div.addEventListener('click',()=>{ div.classList.toggle('active'); updateActiveSetsFromPills(); updateSlicedViews(); });
    pillC.appendChild(div);
  });
  allSelectedHTSCodes.forEach(code=>{
    const div=document.createElement('div'); div.className='pill active'; div.dataset.value=code;
    div.innerHTML='<span class="dot"></span>'+code;
    div.addEventListener('click',()=>{ div.classList.toggle('active'); updateActiveSetsFromPills(); updateSlicedViews(); });
    pillH.appendChild(div);
  });
  updateActiveSetsFromPills();
}
function updateActiveSetsFromPills(){
  const pillC=document.querySelectorAll('#pillCountries .pill'); const pillH=document.querySelectorAll('#pillHts .pill');
  activeCountries = new Set(Array.from(pillC).filter(p=>p.classList.contains('active')).map(p=>p.dataset.value));
  activeHTSCodes = new Set(Array.from(pillH).filter(p=>p.classList.contains('active')).map(p=>p.dataset.value));
}

/* ---------- Init ---------- */
document.addEventListener('DOMContentLoaded', () => {
  // Establish connection to the backend and populate the country list
  connectToAPI();
  updateApiCounterDisplay();
});

document.getElementById('clearBtn').addEventListener('click',()=>{
  document.getElementById('htsCodes').value = '';
  document.getElementById('startDate').value = '';
  document.getElementById('endDate').value = '';

  selectedCountriesList = [];
  allSelectedHTSCodes = [];
  allSelectedCountries = [];
  activeCountries = new Set();
  activeHTSCodes = new Set();

  renderActiveTags();
  renderPills();
  updateActiveSetsFromPills();
  updateSlicedViews();

  document.getElementById('results').textContent = '';
  // Show the results area and put it back into placeholder mode so the
  // background animation and placeholder tables can appear.
  const wrapClear = document.getElementById('resultsWrap');
  if(wrapClear) {
    wrapClear.style.display = 'block';
    wrapClear.classList.add('placeholder-state');
  }
  // Show pivot cards again and apply translucent styling.  Re-render
  // placeholder tables so the user sees a skeletal version of the pivots.
  document.querySelectorAll('.pivot-card').forEach(el => {
    el.style.display = 'block';
    el.style.opacity = '0.75';
  });
  try {
    renderPlaceholderCard('slicedPivotContainer');
    renderPlaceholderCard('slicedPivotValueContainer');
    renderPlaceholderCard('slicedPivotAvgContainer');
    renderNegPlaceholder();
  } catch(_){ console.warn('Placeholder render failed', _); }

  originalRows = [];
  currentTableRows = [];
  currentPivot = null;

  document.getElementById('downloadBtn').disabled = true;
  document.getElementById('qaDownloadCSV').disabled = true;

  document.getElementById('pillCountries').innerHTML = '';
  document.getElementById('pillHts').innerHTML = '';

  // Restart the background animation when clearing selections. The clear
  // action resets the interface to its initial state, so we re-enable
  // the decorative polygon overlay to fill the results area until new
  // data is requested.
  setTimeout(() => {
    try { initBackgroundAnimation(); } catch(_){ }
  }, 0);
});
  </script>
</body>
</html>
