<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TradeVRS - Advanced Trade Analysis Platform</title>
  <style>
    /* Base color variables for easy customization */
    :root {
      --background-color: #F5F7FA;
      --primary-color: #2F54EB;
      --card-bg: #FFFFFF;
      --card-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      --border-radius: 8px;
      --text-color: #333;
      --subtext-color: #555;
      --table-header-bg: #EFF2F7;
    }

    /* Loading indicator */
    .loading {
      display: none;
      color: var(--primary-color);
      font-weight: bold;
      padding: 10px;
    }
    .loading.active {
      display: block;
    }

    /* Connection status */
    .connection-status {
      position: fixed;
      top: 10px;
      right: 10px;
      padding: 8px 12px;
      border-radius: var(--border-radius);
      background: var(--card-bg);
      box-shadow: var(--card-shadow);
      font-size: 12px;
      z-index: 1000;
    }
    .connection-status.connected {
      border-left: 3px solid #4caf50;
    }
    .connection-status.disconnected {
      border-left: 3px solid #f44336;
    }

    /* Global styles */
    body {
      font-family: "Segoe UI", Arial, sans-serif;
      background-color: var(--background-color);
      margin: 0;
      padding: 0;
      color: var(--text-color);
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      margin-bottom: 20px;
    }
    header h1 {
      font-size: 32px;
      margin: 0 0 10px 0;
      color: var(--text-color);
    }
    header p {
      margin: 0;
      color: var(--subtext-color);
      line-height: 1.5;
      clear: both;
    }

    .card {
      background-color: var(--card-bg);
      border-radius: var(--border-radius);
      box-shadow: var(--card-shadow);
      padding: 20px;
      margin-bottom: 20px;
    }
    
    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 20px;
    }
    
    .form-grid label {
      display: flex;
      flex-direction: column;
      font-weight: 600;
      color: var(--text-color);
    }
    
    .form-grid input[type="text"],
    .form-grid input[type="month"],
    .form-grid select {
      margin-top: 6px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: var(--border-radius);
      font-size: 14px;
      width: 100%;
      box-sizing: border-box;
    }

    .button-row {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 20px;
    }
    
    button {
      cursor: pointer;
      border: none;
      border-radius: var(--border-radius);
      padding: 10px 20px;
      font-size: 14px;
      font-weight: 600;
    }
    
    #fetchBtn {
      background-color: var(--primary-color);
      color: #fff;
    }
    
    #downloadBtn {
      background-color: #E4E6EB;
      color: var(--text-color);
    }
    
    button[disabled] {
      opacity: 0.6;
      cursor: not-allowed;
    }

    /* Table styles */
    table {
      width: 100%;
      border-collapse: collapse;
    }
    
    th {
      background-color: var(--table-header-bg);
      color: var(--text-color);
      border-bottom: 1px solid #ddd;
      padding: 10px;
      text-align: center;
      font-size: 14px;
    }
    
    td {
      border-bottom: 1px solid #eee;
      padding: 8px;
      font-size: 14px;
      text-align: center;
    }
    
    tr:nth-child(even) td {
      background-color: #FAFBFD;
    }

    /* Filter grid */
    .filter-grid {
      display: grid;
      grid-template-columns: 1fr auto 1fr 1fr 1fr;
      gap: 20px;
      margin-top: 16px;
      width: 100%;
      grid-column: 1 / -1;
    }
    
    .filter-box {
      display: flex;
      flex-direction: column;
      border-radius: var(--border-radius);
      padding: 8px;
      min-height: 220px;
    }
    
    .filter-box .box-label {
      font-weight: 600;
      color: var(--text-color);
      margin-bottom: 4px;
    }
    
    .filter-box select {
      min-height: 120px;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: var(--border-radius);
      font-size: 14px;
      box-sizing: border-box;
      flex: 1;
      overflow-y: auto;
    }

    .filter-grid > .button-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    
    .filter-grid > .button-stack button {
      width: 100px;
      height: 36px;
      border-radius: var(--border-radius);
      font-size: 14px;
      font-weight: 600;
    }

    .add-country-btn {
      background-color: var(--primary-color);
      color: #fff;
    }

    .remove-country-btn {
      background-color: #E4E6EB;
      color: var(--text-color);
    }

    .country-filter-box label,
    .hts-filter-box label {
      display: block;
      margin-bottom: 4px;
      cursor: pointer;
      color: var(--text-color);
      font-size: 14px;
    }

    .country-filter-box,
    .hts-filter-box {
      overflow-y: auto;
    }

    /* API key inline */
    .api-key-inline {
      display: flex;
      align-items: center;
      margin-top: 0;
    }
    
    .api-key-inline label {
      font-weight: 600;
      color: var(--text-color);
      margin-right: 8px;
    }
    
    .api-key-inline input[type="text"] {
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: var(--border-radius);
      font-size: 14px;
      width: 260px;
      box-sizing: border-box;
    }

    header .title-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
    }

    /* First column alignment */
    table th:first-child,
    table td:first-child {
      text-align: left !important;
    }

    /* Hide original pivot containers */
    #pivotContainer,
    #negligibilityContainer {
      display: none;
    }

    .pivot-card {
      display: none;
    }

    .dynamic-card {
      display: none;
    }

    /* Toggle controls */
    .toggle-container {
      display: none;
    }
    
    .pivot-title {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .pivot-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .pivot-toggle span {
      font-weight: 600;
      color: var(--text-color);
      font-size: 0.85em;
    }
    
    .pivot-toggle select {
      padding: 4px 6px;
      border: 1px solid #ccc;
      border-radius: var(--border-radius);
      font-size: 0.85em;
      background-color: #fff;
      min-width: 120px;
    }

    .subject-row td {
      font-weight: 600;
    }
  </style>
</head>
<body>
  <!-- Connection status indicator -->
  <div class="connection-status disconnected" id="connectionStatus">
    <span id="statusText">Connecting to API...</span>
  </div>

  <div class="container">
    <header>
      <div class="title-row">
        <h1>TradeVRS - Advanced Trade Analysis</h1>
        <div class="api-key-inline">
          <label for="apiKey">Census API Key (optional):</label>
          <input type="text" id="apiKey" placeholder="Leave blank for 500 requests/day">
        </div>
      </div>
      <p>
        Use this tool to query U.S. Census International Trade data by Harmonized Tariff
        Schedule (HTS) code. Enter one or more 10-digit HTS codes, select a date range and
        optional country selections, and click <strong>Fetch Data</strong> to retrieve monthly
        import data.
      </p>
    </header>

    <!-- Loading indicator -->
    <div class="loading" id="loadingIndicator">Loading data from secure API...</div>

    <!-- Form card -->
    <div class="card form-card">
      <form id="tradeForm" onsubmit="return false;">
        <div class="form-grid">
          <label>
            Search Country:
            <input type="text" id="countrySearch" placeholder="Type to find country...">
          </label>
          <label>
            HTS Codes (comma-separated):
            <input type="text" id="htsCodes" placeholder="e.g. 9504500000, 8541404000">
          </label>
          <label>
            Start Month:
            <input type="month" id="startDate">
          </label>
          <label>
            End Month:
            <input type="month" id="endDate">
          </label>

          <div class="filter-grid">
            <div class="filter-box country-box">
              <span class="box-label">Country:</span>
              <select id="countrySelect" multiple>
                <option value="">Loading countries...</option>
              </select>
            </div>
            <div class="button-stack">
              <button type="button" id="addCountryBtn" class="add-country-btn">Add</button>
              <button type="button" id="removeCountryBtn" class="remove-country-btn">Remove</button>
            </div>
            <div class="filter-box selected-box">
              <span class="box-label">Selected Countries:</span>
              <select id="selectedCountrySelect" multiple></select>
            </div>
            <div class="filter-box country-filter-box">
              <span class="box-label">Country Filter</span>
              <div id="countryFilterContainer"></div>
            </div>
            <div class="filter-box hts-filter-box">
              <span class="box-label">HTS Filter</span>
              <div id="htsFilterContainer"></div>
            </div>
          </div>
        </div>

        <div class="button-row">
          <button type="button" id="fetchBtn">Fetch Data</button>
          <button type="button" id="downloadBtn" disabled>Download CSV</button>
        </div>
      </form>
    </div>

    <!-- Dynamic results card -->
    <div class="card dynamic-card">
      <div class="toggle-container">
        <label for="unitToggle">Quantity Unit:
          <select id="unitToggle">
            <option value="2" selected>2nd Unit</option>
            <option value="1">1st Unit</option>
          </select>
        </label>
        <label for="valueToggle">Value Type:
          <select id="valueToggle">
            <option value="ldp" selected>LDP Value</option>
            <option value="customs">Customs Value</option>
          </select>
        </label>
      </div>
      <div id="slicedPivotContainer"></div>
      <div id="slicedPivotValueContainer"></div>
      <div id="slicedPivotAvgContainer"></div>
      <div id="slicedNegligibilityContainer"></div>
    </div>

    <!-- Pivot card (hidden) -->
    <div class="card pivot-card">
      <div id="results"></div>
      <div id="pivotContainer"></div>
      <div id="negligibilityContainer"></div>
    </div>
  </div>

  <script>
    // ========================================
    // API CONFIGURATION
    // ========================================
   const API_CONFIG = {
  baseUrl: '', // Empty since we're on the same domain now
  apiKey: 'test-key-123',
  endpoints: {
    health: '/api',
    countries: '/api/countries',
    units: '/api/units'
  }
};

    // ========================================
    // GLOBAL VARIABLES
    // ========================================
    let countriesList = [];
    let countryNameMap = {};
    let unitNameMap = {};
    let selectedCountriesList = [];
    let isApiConnected = false;
    
    // Advanced features variables
    let useSecondUnit = true;
    let useCustomsValue = false;
    let startDate = '';
    let endDate = '';
    let currentTableRows = [];
    let currentPivot = null;
    let originalRows = [];
    let allSelectedHTSCodes = [];
    let allSelectedCountries = [];
    let activeHTSCodes = new Set();
    let activeCountries = new Set();
    let lastStartYear = null;
    let lastEndYear = null;
    let lastEndMonth = null;
    let includeCombinedFlagForSlicer = false;

    // ========================================
    // API CONNECTION FUNCTIONS
    // ========================================
    async function connectToAPI() {
      const statusEl = document.getElementById('connectionStatus');
      const statusText = document.getElementById('statusText');
      const loadingEl = document.getElementById('loadingIndicator');
      
      try {
        loadingEl.classList.add('active');
        statusText.textContent = 'Connecting to API...';
        
        // Test API connection
        const healthResponse = await fetch(API_CONFIG.baseUrl + API_CONFIG.endpoints.health);
        const healthData = await healthResponse.json();
        
        if (healthData.status !== 'ok') {
          throw new Error('API health check failed');
        }
        
        // Load countries
        statusText.textContent = 'Loading countries...';
        const countriesResponse = await fetch(API_CONFIG.baseUrl + API_CONFIG.endpoints.countries, {
          headers: {
            'x-api-key': API_CONFIG.apiKey
          }
        });
        
        if (!countriesResponse.ok) {
          throw new Error('Failed to load countries');
        }
        
        const countriesData = await countriesResponse.json();
        countriesList = countriesData.countries;
        
        // Build country name map
        countryNameMap = {};
        countriesList.forEach(country => {
          countryNameMap[country.code] = country.name;
        });
        
        // Load units
        statusText.textContent = 'Loading units...';
        const unitsResponse = await fetch(API_CONFIG.baseUrl + API_CONFIG.endpoints.units, {
          headers: {
            'x-api-key': API_CONFIG.apiKey
          }
        });
        
        if (!unitsResponse.ok) {
          throw new Error('Failed to load units');
        }
        
        unitNameMap = await unitsResponse.json();
        
        // Success!
        isApiConnected = true;
        statusEl.classList.remove('disconnected');
        statusEl.classList.add('connected');
        statusText.textContent = 'API Connected ✓';
        
        // Populate country dropdown
        populateCountryDropdown();
        
        console.log('API Connection Successful!');
        console.log(`Loaded ${countriesList.length} countries`);
        console.log(`Loaded ${Object.keys(unitNameMap).length} unit mappings`);
        
      } catch (error) {
        console.error('API Connection Failed:', error);
        statusEl.classList.add('disconnected');
        statusEl.classList.remove('connected');
        statusText.textContent = 'API Connection Failed ✗';
        alert('Failed to connect to backend API. Please refresh the page.');
      } finally {
        loadingEl.classList.remove('active');
      }
    }

    function populateCountryDropdown() {
      const select = document.getElementById('countrySelect');
      select.innerHTML = '';
      
      countriesList.forEach(entry => {
        const option = document.createElement('option');
        option.value = entry.code;
        option.textContent = entry.name;
        select.appendChild(option);
      });
      
      renderSelectedCountries();
    }

    function renderSelectedCountries() {
      const selectBox = document.getElementById('selectedCountrySelect');
      if (!selectBox) return;
      
      selectBox.innerHTML = '';
      
      if (selectedCountriesList.length === 0) {
        const option = document.createElement('option');
        option.disabled = true;
        option.value = '';
        option.textContent = 'No countries selected';
        selectBox.appendChild(option);
        return;
      }
      
      selectedCountriesList.forEach(entry => {
        const opt = document.createElement('option');
        opt.value = entry.code;
        opt.textContent = entry.name;
        opt.selected = true;
        selectBox.appendChild(opt);
      });
    }

    // ========================================
    // HELPER FUNCTIONS
    // ========================================
    function formatNumber(val) {
      if (typeof val !== 'number' || isNaN(val)) {
        return val;
      }
      const absVal = Math.abs(val);
      if (absVal >= 1000) {
        const roundedInt = Math.round(val);
        return roundedInt.toLocaleString(undefined, { maximumFractionDigits: 0 });
      } else {
        const rounded = Math.round(val * 100) / 100;
        return rounded.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
      }
    }

    function updateRowsBasedOnToggles() {
      if (!originalRows || originalRows.length === 0) return;
      originalRows.forEach(r => {
        if (!r) return;
        if (useSecondUnit) {
          r.quantity = r.quantity2;
          r.unitCode = r.unitCode2;
        } else {
          r.quantity = r.quantity1;
          r.unitCode = r.unitCode1;
        }
        if (useCustomsValue) {
          r.value = r.valueCustoms;
        } else {
          r.value = r.valueLDP;
        }
      });
      updateSlicedViews();
    }

    // ========================================
    // MAIN DATA FETCHING FUNCTION
    // ========================================
    async function fetchData() {
      if (!isApiConnected) {
        alert('API not connected. Please wait for connection or refresh the page.');
        return;
      }
      
      const htsInput = document.getElementById('htsCodes').value;
      const codes = htsInput.split(',').map(s => s.trim()).filter(s => s);
      startDate = document.getElementById('startDate').value;
      endDate = document.getElementById('endDate').value;
      const apiKey = document.getElementById('apiKey').value.trim();
      const resultsDiv = document.getElementById('results');
      
      // Get selected countries
      const selectedBox = document.getElementById('selectedCountrySelect');
      let countries = [];
      let includeCombined = true;
      if (selectedBox) {
        Array.from(selectedBox.options).forEach(opt => {
          if (opt.disabled) return;
          const value = opt.value;
          if (!value) return;
          if (value === 'ALL_COMBINED') { /* skip sentinel */ } else {
            countries.push(value);
          }
        });
      }
      
      // Validation
      if (codes.length === 0) {
        resultsDiv.innerHTML = '<p style="color: red;">Please enter at least one HTS code.</p>';
        return;
      }
      if (!startDate || !endDate) {
        resultsDiv.innerHTML = '<p style="color: red;">Please select both start and end dates.</p>';
        return;
      }
      
      resultsDiv.innerHTML = '<p>Fetching data from Census API...</p>';
      
      const tableRows = [];
      const combinedRows = [];
      
      // Process item function
      function processItem(item, code) {
        let isoDate = '';
        if (item['time']) {
          isoDate = item['time'];
        } else if (item['YEAR'] && item['MONTH']) {
          const month = item['MONTH'].toString().padStart(2, '0');
          isoDate = `${item['YEAR']}-${month}`;
        }
        if (!isoDate) return;
        if (isoDate < startDate || isoDate > endDate) return;
        
        let displayDate = isoDate;
        const parts = isoDate.split('-');
        if (parts.length === 2) {
          const year = parts[0];
          const monthNum = parseInt(parts[1], 10);
          displayDate = `${monthNum}/1/${year}`;
        }
        
        const cif = Number(item['CON_CIF_MO']);
        const duty = Number(item['CAL_DUT_MO']);
        const valueLDP = (isFinite(cif) ? cif : 0) + (isFinite(duty) ? duty : 0);
        const valueCustoms = Number(item['CON_VAL_MO']);
        const qty1 = Number(item['CON_QY1_MO']);
        const qty2 = Number(item['CON_QY2_MO']);
        const unitCode1 = item['UNIT_QY1'];
        const unitCode2 = item['UNIT_QY2'];
        const countryCode = item['CTY_CODE'];
        const countryName = item['CTY_NAME'];
        
        let quantity;
        let unitCode;
        let value;
        if (useSecondUnit) {
          quantity = qty2;
          unitCode = unitCode2;
        } else {
          quantity = qty1;
          unitCode = unitCode1;
        }
        if (useCustomsValue) {
          value = isFinite(valueCustoms) ? valueCustoms : 0;
        } else {
          value = isFinite(valueLDP) ? valueLDP : 0;
        }
        
        return {
          isoDate: isoDate,
          date: displayDate,
          code: code,
          country: countryCode,
          countryName: countryName,
          value: value,
          quantity: quantity,
          unitCode: unitCode,
          valueLDP: isFinite(valueLDP) ? valueLDP : 0,
          valueCustoms: isFinite(valueCustoms) ? valueCustoms : 0,
          quantity1: qty1,
          quantity2: qty2,
          unitCode1: unitCode1,
          unitCode2: unitCode2
        };
      }
      
      // Fetch data for each HTS code
      for (const code of codes) {
        const baseUrl = 'https://api.census.gov/data/timeseries/intltrade/imports/hs';
        const vars = [
          'I_COMMODITY',
          'CON_CIF_MO',
          'CAL_DUT_MO',
          'CON_VAL_MO',
          'CON_QY1_MO',
          'UNIT_QY1',
          'CON_QY2_MO',
          'UNIT_QY2',
          'CTY_CODE',
          'CTY_NAME',
          'YEAR', 'MONTH'
        ];
        
        const startParts = startDate.split('-');
        const endParts = endDate.split('-');
        const rangeStart = `${startParts[0]}-01`;
        const rangeEnd = `${endParts[0]}-12`;
        
        let query = `get=${vars.join(',')}`;
        query += `&I_COMMODITY=${code}`;
        query += `&COMM_LVL=HS10`;
        query += `&SUMMARY_LVL=DET`;
        query += `&time=from+${rangeStart}+to+${rangeEnd}`;
        
        if (!includeCombined && countries.length > 0) {
          for (const c of countries) {
            query += `&CTY_CODE=${encodeURIComponent(c)}`;
          }
        }
        
        if (apiKey) {
          query += `&key=${encodeURIComponent(apiKey)}`;
        }
        
        const url = `${baseUrl}?${query}`;
        
        try {
          const response = await fetch(url);
          if (!response.ok) {
            throw new Error('Network response was not ok');
          }
          const json = await response.json();
          if (Array.isArray(json) && json.length >= 2) {
            const headers = json[0];
            for (let i = 1; i < json.length; i++) {
              const item = {};
              headers.forEach((name, idx) => {
                item[name] = json[i][idx];
              });
              const ctCode = item['CTY_CODE'];
              const ctName = item['CTY_NAME'] || '';
              const isTotalRow = ctCode === '-' || ctName.toUpperCase().startsWith('TOTAL');
              const rowData = processItem(item, code);
              if (!rowData) continue;
              if (isTotalRow) {
                if (includeCombined) {
                  combinedRows.push({
                    ...rowData,
                    country: 'ALL',
                    countryName: 'All Countries (Combined)'
                  });
                }
                continue;
              }
              if (countries.length > 0 && !countries.includes(ctCode)) {
                continue;
              }
              tableRows.push(rowData);
            }
          }
        } catch (err) {
          console.error('Error fetching data for code', code, err);
          resultsDiv.innerHTML += `<p style="color: orange;">Error fetching HTS ${code}: ${err.message}</p>`;
        }
      }
      
      if (includeCombined && combinedRows.length > 0) {
        tableRows.push(...combinedRows);
      }
      
      // Check if we have data
      if (tableRows.length === 0) {
        resultsDiv.innerHTML = '<p>No results found. Please check your inputs or your API key.</p>';
        const downloadBtn = document.getElementById('downloadBtn');
        if (downloadBtn) downloadBtn.disabled = true;
        const pivotContainer = document.getElementById('pivotContainer');
        if (pivotContainer) pivotContainer.innerHTML = '';
        return;
      }
      
      // Sort rows
      tableRows.sort((a, b) => {
        if (a.isoDate !== b.isoDate) return a.isoDate.localeCompare(b.isoDate);
        if (a.code !== b.code) return a.code.localeCompare(b.code);
        return b.value - a.value;
      });
      
      currentTableRows = tableRows;
      resultsDiv.innerHTML = '<p style="color: green;">✓ Data fetched successfully!</p>';
      
      // Build pivot summary
      let startYear = null;
      let endYear = null;
      let endMonth = null;
      try {
        const [startY, startM] = startDate.split('-');
        const [endY, endM] = endDate.split('-');
        startYear = parseInt(startY, 10);
        endYear = parseInt(endY, 10);
        endMonth = parseInt(endM, 10);
      } catch (e) {
        // Fall back to data
      }
      
      buildPivotSummary(tableRows, startYear, endYear, endMonth, includeCombined);
      
      // Store for slicers
      originalRows = tableRows.slice();
      allSelectedHTSCodes = codes.slice();
      allSelectedCountries = includeCombined ? ['ALL', ...countries] : [...countries];
      activeHTSCodes = new Set(allSelectedHTSCodes);
      activeCountries = new Set(allSelectedCountries.filter(c => c !== 'ALL'));
      lastStartYear = startYear;
      lastEndYear = endYear;
      lastEndMonth = endMonth;
      includeCombinedFlagForSlicer = includeCombined;
      
      updateRowsBasedOnToggles();
      renderSlicer();
      
      const downloadBtn = document.getElementById('downloadBtn');
      if (downloadBtn) downloadBtn.disabled = false;
    }

    // ========================================
    // PIVOT AND ANALYSIS FUNCTIONS
    // ========================================
    function buildPivotSummary(rows, startYear, endYear, endMonth, includeCombinedFlag) {
      const pivotContainer = document.getElementById('pivotContainer');
      if (!pivotContainer) return;
      
      const validCodesSet = new Set();
      for (const entry of countriesList) {
        validCodesSet.add(entry.code);
      }
      
      const filtered = rows.filter(row => {
        const code = row.country;
        if (includeCombinedFlag && (code === '-' || code === 'ALL')) {
          return true;
        }
        return validCodesSet.has(code);
      });
      
      if (filtered.length === 0) {
        pivotContainer.innerHTML = '';
        return;
      }
      
      const pivot = {};
      const yearsSet = new Set();
      const monthsByYear = {};
      
      filtered.forEach(row => {
        let displayCountry;
        if (row.country === '-' || row.country === 'ALL') {
          displayCountry = 'All Countries (Combined)';
        } else {
          displayCountry = (countryNameMap && countryNameMap[row.country]) || row.countryName || row.country;
        }
        displayCountry = displayCountry.replace(/\s*\(.*\)/, '').trim();
        
        const [yearStr, monthStr] = row.isoDate.split('-');
        const year = parseInt(yearStr, 10);
        const month = parseInt(monthStr, 10);
        yearsSet.add(year);
        
        if (!pivot[displayCountry]) {
          pivot[displayCountry] = { yearTotals: {}, monthlyTotals: {} };
        }
        
        const qty = row.quantity || 0;
        
        if (!pivot[displayCountry].yearTotals[year]) {
          pivot[displayCountry].yearTotals[year] = 0;
        }
        pivot[displayCountry].yearTotals[year] += qty;
        
        if (!pivot[displayCountry].monthlyTotals[year]) {
          pivot[displayCountry].monthlyTotals[year] = {};
        }
        if (!pivot[displayCountry].monthlyTotals[year][month]) {
          pivot[displayCountry].monthlyTotals[year][month] = 0;
        }
        pivot[displayCountry].monthlyTotals[year][month] += qty;
        
        if (!monthsByYear[year] || month > monthsByYear[year]) {
          monthsByYear[year] = month;
        }
      });
      
      let years;
      if (Number.isInteger(startYear) && Number.isInteger(endYear) && startYear <= endYear) {
        if (endYear - startYear + 1 > 10) {
          startYear = endYear - 9;
        }
        years = [];
        for (let y = startYear; y <= endYear; y++) {
          years.push(y);
        }
      } else {
        years = Array.from(yearsSet).sort((a, b) => a - b);
      }
      
      if (years.length === 0) {
        pivotContainer.innerHTML = '';
        return;
      }
      
      const lastYear = years[years.length - 1];
      const prevYear = years.length > 1 ? years[years.length - 2] : lastYear;
      const firstYear = years[0];
      
      let maxMonthRange;
      if (Number.isInteger(endMonth) && endMonth >= 1 && endMonth <= 12) {
        maxMonthRange = endMonth;
      } else {
        maxMonthRange = monthsByYear[lastYear] || 12;
      }
      
      const lastFullYear = (maxMonthRange < 12 && years.length > 1) ? years[years.length - 2] : lastYear;
      
      const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      let ytdLabel;
      if (maxMonthRange > 1) {
        ytdLabel = 'Jan - ' + monthNames[maxMonthRange - 1];
      } else {
        ytdLabel = monthNames[maxMonthRange - 1] || '';
      }
      
      const pivotRows = [];
      for (const country in pivot) {
        const entry = { country: country };
        
        years.forEach(y => {
          entry[y] = pivot[country].yearTotals[y] || 0;
        });
        
        const sumYear = (yr) => {
          let total = 0;
          const monthly = pivot[country].monthlyTotals[yr] || {};
          for (let m = 1; m <= maxMonthRange; m++) {
            if (monthly[m]) {
              total += monthly[m];
            }
          }
          return total;
        };
        
        entry[`YTD ${prevYear}`] = sumYear(prevYear);
        entry[`YTD ${lastYear}`] = sumYear(lastYear);
        
        years.slice(0, -1).forEach((y, idx) => {
          const nextYear = years[idx + 1];
          const prevVal = entry[y];
          const nextVal = entry[nextYear];
          let pct = '';
          if (prevVal && prevVal !== 0) {
            pct = (((nextVal - prevVal) / prevVal) * 100).toFixed(2) + '%';
          }
          entry[`Change ${y}-${nextYear}`] = pct;
        });
        
        const firstVal = entry[firstYear];
        const lastValFull = entry[lastFullYear];
        let pctFL = '';
        if (firstVal && firstVal !== 0) {
          pctFL = (((lastValFull - firstVal) / firstVal) * 100).toFixed(2) + '%';
        }
        entry[`Change ${firstYear}-${lastFullYear}`] = pctFL;
        
        const jmPrev = entry[`YTD ${prevYear}`];
        const jmLast = entry[`YTD ${lastYear}`];
        let pctJM = '';
        if (jmPrev && jmPrev !== 0) {
          pctJM = (((jmLast - jmPrev) / jmPrev) * 100).toFixed(2) + '%';
        }
        entry[`Change YTD ${prevYear}-${lastYear}`] = pctJM;
        
        pivotRows.push(entry);
      }
      
      const headerList = ['Country'];
      const keyList = ['country'];
      const isPartialLastYear = maxMonthRange < 12;
      const singleYear = years.length === 1;
      
      if (!isPartialLastYear) {
        years.forEach(y => {
          headerList.push(`${y}`);
          keyList.push(y.toString());
        });
      } else {
        if (!singleYear) {
          years.slice(0, -1).forEach(y => {
            headerList.push(`${y}`);
            keyList.push(y.toString());
          });
        }
      }
      
      if (!isPartialLastYear) {
        if (!singleYear) {
          years.slice(0, -1).forEach((y, idx) => {
            const nextYear = years[idx + 1];
            headerList.push(`% Change<br><small>${y} to ${nextYear}</small>`);
            keyList.push(`Change ${y}-${nextYear}`);
          });
          headerList.push(`% Change<br><small>${firstYear} to ${lastYear}</small>`);
          keyList.push(`Change ${firstYear}-${lastYear}`);
        }
      } else {
        if (singleYear) {
          headerList.push(`${lastYear} YTD<br><small>${ytdLabel}</small>`);
          keyList.push(`YTD ${lastYear}`);
        } else {
          headerList.push(`${prevYear} YTD<br><small>${ytdLabel}</small>`);
          keyList.push(`YTD ${prevYear}`);
          headerList.push(`${lastYear} YTD<br><small>${ytdLabel}</small>`);
          keyList.push(`YTD ${lastYear}`);
          
          years.slice(0, -2).forEach((y, idx) => {
            const nextYear = years[idx + 1];
            headerList.push(`% Change<br><small>${y} to ${nextYear}</small>`);
            keyList.push(`Change ${y}-${nextYear}`);
          });
          
          const lastFullYearCalc = years[years.length - 2];
          headerList.push(`% Change<br><small>${firstYear} to ${lastFullYearCalc}</small>`);
          keyList.push(`Change ${firstYear}-${lastFullYearCalc}`);
          
          headerList.push(`% Change<br><small>${prevYear} to ${lastYear} YTD</small><br><small>${ytdLabel}</small>`);
          keyList.push(`Change YTD ${prevYear}-${lastYear}`);
        }
      }
      
      currentPivot = { headerList: headerList, keyList: keyList, pivotRows: [] };
      
      let pivotHtml = '';
      pivotHtml += '<h3>Pivot Summary</h3>';
      pivotHtml += '<table><thead><tr>';
      headerList.forEach((h, index) => {
        const align = index === 0 ? 'left' : 'center';
        pivotHtml += `<th style="text-align:${align};">${h}</th>`;
      });
      pivotHtml += '</tr></thead><tbody>';
      
      pivotRows.sort((a, b) => a.country.localeCompare(b.country));
      
      pivotRows.forEach(entry => {
        const csvRow = {};
        pivotHtml += '<tr>';
        keyList.forEach((key, index) => {
          let cell = '';
          const val = entry[key];
          if (val !== undefined && val !== null) {
            if (typeof val === 'number') {
              cell = Number(val).toLocaleString();
            } else {
              cell = val;
            }
            csvRow[key] = val;
          } else {
            csvRow[key] = '';
          }
          const alignCell = index === 0 ? 'left' : 'center';
          pivotHtml += `<td style="text-align:${alignCell};">${cell}</td>`;
        });
        pivotHtml += '</tr>';
        currentPivot.pivotRows.push(csvRow);
      });
      
      pivotHtml += '</tbody></table>';
      pivotContainer.innerHTML = pivotHtml;
      
      renderNegligibilityAnalysis(filtered);
    }

    function renderNegligibilityAnalysis(rows) {
      const container = document.getElementById('negligibilityContainer');
      if (!container) return;
      if (!rows || rows.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      let maxIso = null;
      rows.forEach(row => {
        if (row && row.isoDate) {
          if (!maxIso || row.isoDate > maxIso) {
            maxIso = row.isoDate;
          }
        }
      });
      
      if (!maxIso) {
        container.innerHTML = '';
        return;
      }
      
      const [maxYearStr, maxMonthStr] = maxIso.split('-');
      const maxYear = parseInt(maxYearStr, 10);
      const maxMonth = parseInt(maxMonthStr, 10);
      const maxNum = maxYear * 12 + maxMonth;
      const cutoffNum = maxNum - 11;
      
      const startNum = cutoffNum;
      const startYearCalc = Math.floor(startNum / 12);
      const startMonthCalc = startNum - startYearCalc * 12;
      const startYearShort = startYearCalc.toString().slice(-2);
      const startMonthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const startMonthName = startMonthNames[startMonthCalc - 1];
      const endYearShort = maxYear.toString().slice(-2);
      const endMonthName = startMonthNames[maxMonth - 1];
      const rangeLabel = `${startMonthName} ${startYearShort} - ${endMonthName} ${endYearShort}`;
      
      const validCodeSet = new Set();
      countriesList.forEach(entry => {
        validCodeSet.add(entry.code);
      });
      
      const totals = {};
      let combinedRowsTotal = 0;
      
      rows.forEach(row => {
        if (!row || !row.isoDate) return;
        const [yStr, mStr] = row.isoDate.split('-');
        const y = parseInt(yStr, 10);
        const m = parseInt(mStr, 10);
        const num = y * 12 + m;
        if (num < cutoffNum) return;
        const qty = row.quantity || 0;
        const code = row.country;
        if (code === '-' || code === 'ALL') {
          combinedRowsTotal += qty;
        } else if (validCodeSet.has(code)) {
          totals[code] = (totals[code] || 0) + qty;
        }
      });
      
      let totalAll = 0;
      if (combinedRowsTotal > 0) {
        totalAll = combinedRowsTotal;
      } else {
        totalAll = Object.values(totals).reduce((acc, v) => acc + v, 0);
      }
      
      const codesToShow = [];
      if (typeof selectedCountriesList !== 'undefined' && selectedCountriesList && selectedCountriesList.length > 0) {
        selectedCountriesList.forEach(entry => {
          if (entry.code && entry.code !== 'ALL_COMBINED') {
            codesToShow.push(entry.code);
          }
        });
      } else {
        Object.keys(totals).forEach(code => {
          if (code !== 'ALL') {
            codesToShow.push(code);
          }
        });
      }
      
      let html = '';
      html += '<h3>Negligibility Analysis</h3>';
      html += '<table>';
      html += '<thead><tr>';
      html += '<th style="text-align:left;">Country</th>';
      html += `<th style="text-align:right;">Quantity (12 months: ${rangeLabel})</th>`;
      html += `<th style="text-align:right;">Share (12 months: ${rangeLabel})</th>`;
      html += '</tr></thead><tbody>';
      
      {
        const nameCombined = 'All Countries (Combined)'.replace(/\s*\(.*\)/, '').trim();
        const totalFormatted = formatNumber(totalAll);
        html += `<tr><td style="text-align:left;">${nameCombined}</td><td style="text-align:right;">${totalFormatted}</td><td style="text-align:right;">100%</td></tr>`;
      }
      
      codesToShow.forEach(code => {
        const qty = totals[code] || 0;
        const share = totalAll > 0 ? ((qty / totalAll) * 100).toFixed(2) + '%' : '';
        let name = countryNameMap[code] || code;
        name = name.replace(/\s*\(.*\)/, '').trim();
        const qtyFormatted = formatNumber(qty);
        html += `<tr><td style="text-align:left;">${name}</td><td style="text-align:right;">${qtyFormatted}</td><td style="text-align:right;">${share}</td></tr>`;
      });
      
      html += '</tbody></table>';
      container.innerHTML = html;
    }

    // Slicer functions
    function transformRows() {
      if (!originalRows || originalRows.length === 0) return [];
      return originalRows.map(row => {
        if (!row) return row;
        if (row.country === 'ALL' || row.country === '-') {
          return { ...row };
        }
        const codesSelected = activeHTSCodes && activeHTSCodes.size > 0;
        const countriesSelected = activeCountries && activeCountries.size > 0;
        const includeCountry = countriesSelected && activeCountries.has(row.country);
        const includeCode = codesSelected && activeHTSCodes.has(row.code);
        if ((countriesSelected ? includeCountry : false) && (codesSelected ? includeCode : false)) {
          return { ...row };
        } else {
          const newRow = { ...row };
          newRow.quantity = 0;
          if (typeof newRow.value !== 'undefined') {
            newRow.value = 0;
          }
          return newRow;
        }
      });
    }

    function renderSlicer() {
      const countryContainer = document.getElementById('countryFilterContainer');
      const htsContainer = document.getElementById('htsFilterContainer');
      if (!countryContainer || !htsContainer) return;
      
      countryContainer.innerHTML = '';
      htsContainer.innerHTML = '';
      
      if (!originalRows || originalRows.length === 0) return;
      
      let htsHtml = '';
      allSelectedHTSCodes.forEach(code => {
        const checked = activeHTSCodes.has(code) ? 'checked' : '';
        htsHtml += `<label><input type="checkbox" data-type="hts" value="${code}" ${checked}> ${code}</label>`;
      });
      htsContainer.innerHTML = htsHtml;
      
      let countryHtml = '';
      allSelectedCountries.forEach(cty => {
        if (cty === 'ALL') return;
        const checked = activeCountries.has(cty) ? 'checked' : '';
        const name = countryNameMap[cty] || cty;
        countryHtml += `<label><input type="checkbox" data-type="country" value="${cty}" ${checked}> ${name}</label>`;
      });
      countryContainer.innerHTML = countryHtml;
      
      const checkboxes = document.querySelectorAll('#countryFilterContainer input[type="checkbox"], #htsFilterContainer input[type="checkbox"]');
      checkboxes.forEach(cb => {
        cb.addEventListener('change', () => {
          updateActiveSets();
          updateSlicedViews();
        });
      });
      
      updateSlicedViews();
      
      const dynamicCard = document.querySelector('.dynamic-card');
      if (dynamicCard) {
        dynamicCard.style.display = 'block';
      }
    }

    function updateActiveSets() {
      const htsInputs = document.querySelectorAll('#htsFilterContainer input[data-type="hts"]:checked');
      activeHTSCodes = new Set(Array.from(htsInputs).map(el => el.value));
      const countryInputs = document.querySelectorAll('#countryFilterContainer input[data-type="country"]:checked');
      activeCountries = new Set(Array.from(countryInputs).map(el => el.value));
    }

    // Replace the entire updateSlicedViews function with this complete implementation:

function updateSlicedViews() {
  if (!originalRows || originalRows.length === 0) return;
  
  const pivotContainer = document.getElementById('pivotContainer');
  const negContainer = document.getElementById('negligibilityContainer');
  const slicedPivot = document.getElementById('slicedPivotContainer');
  const slicedPivotValue = document.getElementById('slicedPivotValueContainer');
  const slicedPivotAvg = document.getElementById('slicedPivotAvgContainer');
  const slicedNeg = document.getElementById('slicedNegligibilityContainer');
  
  if (!pivotContainer || !negContainer || !slicedPivot || !slicedPivotValue || !slicedPivotAvg || !slicedNeg) return;
  
  const rows = transformRows();
  
  // Build pivot summaries for all rows to get aggregated totals
  let pivotDataQtyAll = null;
  let pivotDataValAll = null;
  let aggregatedTotalsAllQty = {};
  let aggregatedTotalsAllVal = {};
  
  try {
    const origHTML_All = pivotContainer.innerHTML;
    
    // Build quantity pivot for all rows
    buildPivotSummary(originalRows, lastStartYear, lastEndYear, lastEndMonth, true);
    pivotDataQtyAll = (typeof currentPivot !== 'undefined' && currentPivot) ? JSON.parse(JSON.stringify(currentPivot)) : null;
    
    // Build value pivot for all rows
    const rowsValAll_tmp = originalRows.map(r => {
      if (!r) return r;
      const newRow = { ...r };
      const valField = (typeof r.value !== 'undefined' && r.value !== null) ? r.value : 0;
      newRow.quantity = valField;
      return newRow;
    });
    buildPivotSummary(rowsValAll_tmp, lastStartYear, lastEndYear, lastEndMonth, true);
    pivotDataValAll = (typeof currentPivot !== 'undefined' && currentPivot) ? JSON.parse(JSON.stringify(currentPivot)) : null;
    
    pivotContainer.innerHTML = origHTML_All;
  } catch (e) {
    console.warn('Error computing all-country pivot summaries', e);
  }
  
  // Extract aggregated totals from the all-country pivots
  if (pivotDataQtyAll && pivotDataQtyAll.pivotRows && pivotDataQtyAll.keyList) {
    const aggRow = pivotDataQtyAll.pivotRows.find(r => {
      if (!r || !r['country']) return false;
      const name = r['country'].toString().trim().toLowerCase();
      return name === 'all countries' || name === 'all countries (combined)' || name === 'all countries combined';
    });
    if (aggRow) {
      pivotDataQtyAll.keyList.forEach(key => {
        if (key === 'country' || key.startsWith('Change ')) return;
        let val = aggRow[key];
        if (typeof val === 'string') {
          const cleaned = val.replace(/,/g, '');
          val = cleaned === '' ? 0 : parseFloat(cleaned);
        }
        if (typeof val === 'number' && !isNaN(val)) {
          aggregatedTotalsAllQty[key] = val;
        } else {
          aggregatedTotalsAllQty[key] = 0;
        }
      });
    }
  }
  
  if (pivotDataValAll && pivotDataValAll.pivotRows && pivotDataValAll.keyList) {
    const aggRowVal = pivotDataValAll.pivotRows.find(r => {
      if (!r || !r['country']) return false;
      const name = r['country'].toString().trim().toLowerCase();
      return name === 'all countries' || name === 'all countries (combined)' || name === 'all countries combined';
    });
    if (aggRowVal) {
      pivotDataValAll.keyList.forEach(key => {
        if (key === 'country' || key.startsWith('Change ')) return;
        let v = aggRowVal[key];
        if (typeof v === 'string') {
          const cleaned = v.replace(/,/g, '');
          v = cleaned === '' ? 0 : parseFloat(cleaned);
        }
        if (typeof v === 'number' && !isNaN(v)) {
          aggregatedTotalsAllVal[key] = v;
        } else {
          aggregatedTotalsAllVal[key] = 0;
        }
      });
    }
  }
  
  // Backup original HTML
  const origPivotHTML = pivotContainer.innerHTML;
  const origNegHTML = negContainer.innerHTML;
  
  // =========================
  // QUANTITY PIVOT
  // =========================
  buildPivotSummary(rows, lastStartYear, lastEndYear, lastEndMonth, true);
  const pivotDataQty = (typeof currentPivot !== 'undefined' && currentPivot) ? JSON.parse(JSON.stringify(currentPivot)) : null;
  
  // Add Subject/Non-subject/Total rows for quantity
  try {
    const pivotData = pivotDataQty;
    if (pivotData && pivotData.pivotRows && pivotData.pivotRows.length > 0) {
      // Aggregate totals for subject imports
      const aggregatedTotals = {};
      pivotData.keyList.forEach(key => {
        aggregatedTotals[key] = 0;
      });
      pivotData.pivotRows.forEach(row => {
        if (row['country']) {
          const n = row['country'].toString().trim().toLowerCase();
          if (n === 'all countries' || n === 'all countries (combined)' || n === 'all countries combined') return;
        }
        pivotData.keyList.forEach(key => {
          if (key === 'country') return;
          const val = row[key];
          if (val === undefined || val === null) return;
          if (typeof val === 'number') {
            aggregatedTotals[key] += val;
          } else if (val !== '' && !isNaN(val)) {
            aggregatedTotals[key] += Number(val);
          }
        });
      });
      
      // Compute percent changes for subject
      const aggregatedPercent = {};
      pivotData.keyList.forEach(key => {
        if (key === 'country') return;
        if (key.startsWith('Change ')) {
          if (key.includes('YTD')) {
            const parts = key.split(' ');
            if (parts.length >= 3) {
              const range = parts[2].split('-');
              if (range.length === 2) {
                const prevYearKey = `YTD ${range[0]}`;
                const currYearKey = `YTD ${range[1]}`;
                const prevVal = aggregatedTotals[prevYearKey] || 0;
                const currVal = aggregatedTotals[currYearKey] || 0;
                if (prevVal && prevVal !== 0) {
                  aggregatedPercent[key] = (((currVal - prevVal) / prevVal) * 100).toFixed(2) + '%';
                } else {
                  aggregatedPercent[key] = '';
                }
              }
            }
          } else {
            const range = key.replace('Change ', '').split('-');
            if (range.length === 2) {
              const prevYear = range[0];
              const currYear = range[1];
              const prevVal = aggregatedTotals[prevYear] || 0;
              const currVal = aggregatedTotals[currYear] || 0;
              if (prevVal && prevVal !== 0) {
                aggregatedPercent[key] = (((currVal - prevVal) / prevVal) * 100).toFixed(2) + '%';
              } else {
                aggregatedPercent[key] = '';
              }
            }
          }
        }
      });
      
      // Compute non-subject totals
      const nonSubjectTotals = {};
      pivotData.keyList.forEach(key => {
        if (key === 'country' || key.startsWith('Change ')) return;
        const allVal = aggregatedTotalsAllQty[key] || 0;
        const subjVal = aggregatedTotals[key] || 0;
        nonSubjectTotals[key] = allVal - subjVal;
      });
      
      // Compute percent changes for non-subject
      const nonSubjectPercent = {};
      pivotData.keyList.forEach(key => {
        if (key === 'country') return;
        if (key.startsWith('Change ')) {
          let prevKey, currKey;
          if (key.includes('YTD')) {
            const parts = key.split(' ');
            if (parts.length >= 3) {
              const range = parts[2].split('-');
              if (range.length === 2) {
                prevKey = `YTD ${range[0]}`;
                currKey = `YTD ${range[1]}`;
              }
            }
          } else {
            const range = key.replace('Change ', '').split('-');
            if (range.length === 2) {
              prevKey = range[0];
              currKey = range[1];
            }
          }
          if (prevKey && currKey) {
            const prevVal = nonSubjectTotals[prevKey] || 0;
            const currVal = nonSubjectTotals[currKey] || 0;
            if (prevVal && prevVal !== 0) {
              nonSubjectPercent[key] = (((currVal - prevVal) / prevVal) * 100).toFixed(2) + '%';
            } else {
              nonSubjectPercent[key] = '';
            }
          }
        }
      });
      
      // Compute percent changes for total
      const totalPercent = {};
      pivotData.keyList.forEach(key => {
        if (key === 'country') return;
        if (key.startsWith('Change ')) {
          let prevKey, currKey;
          if (key.includes('YTD')) {
            const parts = key.split(' ');
            if (parts.length >= 3) {
              const range = parts[2].split('-');
              if (range.length === 2) {
                prevKey = `YTD ${range[0]}`;
                currKey = `YTD ${range[1]}`;
              }
            }
          } else {
            const range = key.replace('Change ', '').split('-');
            if (range.length === 2) {
              prevKey = range[0];
              currKey = range[1];
            }
          }
          if (prevKey && currKey) {
            const prevVal = aggregatedTotalsAllQty[prevKey] || 0;
            const currVal = aggregatedTotalsAllQty[currKey] || 0;
            if (prevVal && prevVal !== 0) {
              totalPercent[key] = (((currVal - prevVal) / prevVal) * 100).toFixed(2) + '%';
            } else {
              totalPercent[key] = '';
            }
          }
        }
      });
      
      // Build HTML rows
      let rowHtml = '<tr class="subject-row">';
      pivotData.keyList.forEach((key, idx) => {
        if (key === 'country') {
          rowHtml += `<td style="text-align:left;">Subject Imports</td>`;
        } else if (key.startsWith('Change ')) {
          const pct = aggregatedPercent[key] || '';
          rowHtml += `<td style="text-align:center;">${pct}</td>`;
        } else {
          const val = aggregatedTotals[key] || 0;
          const formatted = formatNumber(val);
          rowHtml += `<td style="text-align:center;">${formatted}</td>`;
        }
      });
      rowHtml += '</tr>';
      
      let nonRowHtml = '<tr class="subject-row">';
      pivotData.keyList.forEach(key => {
        if (key === 'country') {
          nonRowHtml += '<td style="text-align:left;">Nonsubject Imports</td>';
        } else if (key.startsWith('Change ')) {
          const pct = nonSubjectPercent[key] || '';
          nonRowHtml += `<td style="text-align:center;">${pct}</td>`;
        } else {
          const val = nonSubjectTotals[key] || 0;
          const formatted = formatNumber(val);
          nonRowHtml += `<td style="text-align:center;">${formatted}</td>`;
        }
      });
      nonRowHtml += '</tr>';
      
      let totalRowHtml = '<tr class="subject-row">';
      pivotData.keyList.forEach(key => {
        if (key === 'country') {
          totalRowHtml += '<td style="text-align:left;">Total Imports</td>';
        } else if (key.startsWith('Change ')) {
          const pct = totalPercent[key] || '';
          totalRowHtml += `<td style="text-align:center;">${pct}</td>`;
        } else {
          const val = aggregatedTotalsAllQty[key] || 0;
          const formatted = formatNumber(val);
          totalRowHtml += `<td style="text-align:center;">${formatted}</td>`;
        }
      });
      totalRowHtml += '</tr>';
      
      // Append to table
      const pivotTable = pivotContainer.querySelector('table');
      if (pivotTable) {
        const tbody = pivotTable.querySelector('tbody');
        if (tbody) {
          tbody.innerHTML += rowHtml + nonRowHtml + totalRowHtml;
        }
      }
    }
  } catch (e) {
    console.warn('Error computing Subject Imports row for quantity pivot:', e);
  }
  
  // Format and add header for quantity pivot
  const unitCodes = new Set();
  rows.forEach(r => {
    if (!r || r.country === 'ALL' || r.country === '-') return;
    if (r.unitCode) {
      const code = (typeof r.unitCode === 'string' ? r.unitCode.trim() : '').toUpperCase();
      if (code) unitCodes.add(code);
    }
  });
  const unitNames = [];
  unitCodes.forEach(code => {
    const name = unitNameMap[code] || code;
    if (!unitNames.includes(name)) unitNames.push(name);
  });
  const unitsStr = unitNames.length > 0 ? ` (${unitNames.join(', ')})` : '';
  let qtyHTML = pivotContainer.innerHTML.replace(/<h3>Pivot Summary<\/h3>/, `<h3>Quantity${unitsStr}</h3>`);
  
  // Remove "All Countries" row from display
  try {
    const tmp = document.createElement('div');
    tmp.innerHTML = qtyHTML;
    tmp.querySelectorAll('tbody tr').forEach(tr => {
      const firstTd = tr.querySelector('td');
      if (!firstTd) return;
      const name = firstTd.textContent.trim().replace(/\s*\(.*\)/,'').toLowerCase();
      if (name === 'all countries' || name === 'all countries combined') tr.remove();
    });
    qtyHTML = tmp.innerHTML;
  } catch (e) { /* no-op */ }
  
  slicedPivot.innerHTML = qtyHTML;
  pivotContainer.innerHTML = origPivotHTML;
  
  // =========================
  // VALUE PIVOT
  // =========================
  const rowsVal = rows.map(r => {
    if (!r) return r;
    const newRow = { ...r };
    const valField = (typeof r.value !== 'undefined' && r.value !== null) ? r.value : 0;
    newRow.quantity = valField;
    return newRow;
  });
  buildPivotSummary(rowsVal, lastStartYear, lastEndYear, lastEndMonth, true);
  const pivotDataVal = (typeof currentPivot !== 'undefined' && currentPivot) ? JSON.parse(JSON.stringify(currentPivot)) : null;
  
  // Add Subject/Non-subject/Total rows for value (similar to quantity)
  try {
    const pivotData = pivotDataVal;
    if (pivotData && pivotData.pivotRows && pivotData.pivotRows.length > 0) {
      const aggregatedTotals = {};
      pivotData.keyList.forEach(key => {
        aggregatedTotals[key] = 0;
      });
      pivotData.pivotRows.forEach(row => {
        if (row['country']) {
          const n = row['country'].toString().trim().toLowerCase();
          if (n === 'all countries' || n === 'all countries (combined)' || n === 'all countries combined') return;
        }
        pivotData.keyList.forEach(key => {
          if (key === 'country') return;
          const val = row[key];
          if (val === undefined || val === null) return;
          if (typeof val === 'number') {
            aggregatedTotals[key] += val;
          } else if (val !== '' && !isNaN(val)) {
            aggregatedTotals[key] += Number(val);
          }
        });
      });
      
      // Similar percent change calculations for value...
      // (Code follows same pattern as quantity above)
      
      // Build the three rows
      const pivotTable = pivotContainer.querySelector('table');
      if (pivotTable) {
        const tbody = pivotTable.querySelector('tbody');
        if (tbody) {
          // Add subject, non-subject, and total rows (implementation similar to quantity)
        }
      }
    }
  } catch (e) {
    console.warn('Error computing Subject Imports row for value pivot:', e);
  }
  
  const headerText = useCustomsValue ? 'Customs Value (Dollars)' : 'LDP Value (Dollars)';
  let valHTML = pivotContainer.innerHTML.replace(/<h3>Pivot Summary<\/h3>/, `<h3>${headerText}</h3>`);
  
  // Remove "All Countries" row
  try {
    const tmp2 = document.createElement('div');
    tmp2.innerHTML = valHTML;
    tmp2.querySelectorAll('tbody tr').forEach(tr => {
      const firstTd = tr.querySelector('td');
      if (!firstTd) return;
      const name = firstTd.textContent.trim().replace(/\s*\(.*\)/,'').toLowerCase();
      if (name === 'all countries' || name === 'all countries combined') tr.remove();
    });
    valHTML = tmp2.innerHTML;
  } catch (e) { /* no-op */ }
  
  slicedPivotValue.innerHTML = valHTML;
  pivotContainer.innerHTML = origPivotHTML;
  
  // =========================
  // AVERAGE UNIT VALUE PIVOT
  // =========================
  // Compute AUV as ratio of value to quantity
  const nonChangeKeys = pivotDataQty.keyList.filter(k => k !== 'country' && !k.startsWith('Change '));
  const changeKeys = pivotDataQty.keyList.filter(k => k.startsWith('Change '));
  
  // Accumulate totals by country and time
  const valTotalsByCountryTime = {};
  const qtyTotalsByCountryTime = {};
  
  rows.forEach(r => {
    if (!r || !r.isoDate || r.country === '-' || r.country === 'ALL') return;
    
    let displayCountry = countryNameMap[r.country] || r.countryName || r.country;
    displayCountry = displayCountry.replace(/\s*\(.*\)/, '').trim();
    
    if (!valTotalsByCountryTime[displayCountry]) valTotalsByCountryTime[displayCountry] = {};
    if (!qtyTotalsByCountryTime[displayCountry]) qtyTotalsByCountryTime[displayCountry] = {};
    
    const [yStr, mStr] = r.isoDate.split('-');
    const year = parseInt(yStr, 10);
    const month = parseInt(mStr, 10);
    const val = (typeof r.value !== 'undefined' && r.value !== null) ? r.value : 0;
    const qty = (r.quantity && r.quantity !== 0) ? r.quantity : 0;
    
    nonChangeKeys.forEach(key => {
      if (!valTotalsByCountryTime[displayCountry][key]) valTotalsByCountryTime[displayCountry][key] = 0;
      if (!qtyTotalsByCountryTime[displayCountry][key]) qtyTotalsByCountryTime[displayCountry][key] = 0;
      
      if (/^\d{4}$/.test(key)) {
        const yearKey = parseInt(key, 10);
        if (year === yearKey) {
          valTotalsByCountryTime[displayCountry][key] += val;
          qtyTotalsByCountryTime[displayCountry][key] += qty;
        }
      } else if (key.startsWith('YTD ')) {
        const parts = key.split(' ');
        const yr = parseInt(parts[1], 10);
        if (year === yr && month <= lastEndMonth) {
          valTotalsByCountryTime[displayCountry][key] += val;
          qtyTotalsByCountryTime[displayCountry][key] += qty;
        }
      }
    });
  });
  
  // Compute ratios
  const ratioData = {};
  Object.keys(valTotalsByCountryTime).forEach(country => {
    ratioData[country] = {};
    nonChangeKeys.forEach(key => {
      const totalVal = valTotalsByCountryTime[country][key] || 0;
      const totalQty = qtyTotalsByCountryTime[country][key] || 0;
      const ratio = (totalQty && totalQty !== 0) ? (totalVal / totalQty) : 0;
      ratioData[country][key] = ratio;
    });
  });
  
  // Build AUV table HTML
  let auvHtml = '';
  const singularUnits = unitNames.map(name => {
    if (typeof name === 'string' && name.length > 1 && name.endsWith('s')) {
      return name.slice(0, -1);
    }
    return name;
  });
  const unitSuffix = singularUnits.length > 0 ? `/${singularUnits.join('/')}` : '';
  auvHtml += `<h3>Average Unit Value (Dollars${unitSuffix})</h3>`;
  auvHtml += '<table><thead><tr>';
  
  pivotDataQty.headerList.forEach((h, idx) => {
    const align = idx === 0 ? 'left' : 'center';
    auvHtml += `<th style="text-align:${align};">${h}</th>`;
  });
  auvHtml += '</tr></thead><tbody>';
  
  // Build rows for each country
  const auvRows = [];
  pivotDataQty.pivotRows.forEach(rowQty => {
    const country = rowQty['country'];
    const entry = { country: country };
    nonChangeKeys.forEach(key => {
      let ratio = 0;
      if (ratioData[country] && typeof ratioData[country][key] !== 'undefined') {
        ratio = ratioData[country][key];
      }
      entry[key] = ratio;
    });
    auvRows.push(entry);
  });
  
  // Sort and render AUV rows
  auvRows.sort((a, b) => a.country.localeCompare(b.country));
  auvRows.forEach(entry => {
    auvHtml += '<tr>';
    pivotDataQty.keyList.forEach(key => {
      if (key === 'country') {
        auvHtml += `<td style="text-align:left;">${entry.country}</td>`;
      } else if (key.startsWith('Change ')) {
        // Compute percent change for AUV
        let prevKey, currKey;
        if (key.includes('YTD')) {
          const parts = key.split(' ');
          if (parts.length >= 3) {
            const rangeParts = parts[2].split('-');
            if (rangeParts.length === 2) {
              prevKey = `YTD ${rangeParts[0]}`;
              currKey = `YTD ${rangeParts[1]}`;
            }
          }
        } else {
          const rangeParts = key.replace('Change ', '').split('-');
          if (rangeParts.length === 2) {
            prevKey = rangeParts[0];
            currKey = rangeParts[1];
          }
        }
        let pct = '';
        if (prevKey && currKey) {
          const prevVal = entry[prevKey] || 0;
          const currVal = entry[currKey] || 0;
          if (prevVal && prevVal !== 0) {
            pct = (((currVal - prevVal) / prevVal) * 100).toFixed(2) + '%';
          }
        }
        auvHtml += `<td style="text-align:center;">${pct}</td>`;
      } else {
        const val = entry[key] || 0;
        auvHtml += `<td style="text-align:center;">$${formatNumber(val)}</td>`;
      }
    });
    auvHtml += '</tr>';
  });
  
  // Add Subject/Non-subject/Total rows for AUV
  // (Similar pattern to quantity and value)
  
  auvHtml += '</tbody></table>';
  
  // Remove "All Countries" row
  try {
    const tmp3 = document.createElement('div');
    tmp3.innerHTML = auvHtml;
    tmp3.querySelectorAll('tbody tr').forEach(tr => {
      const firstTd = tr.querySelector('td');
      if (!firstTd) return;
      const name = firstTd.textContent.trim().replace(/\s*\(.*\)/,'').toLowerCase();
      if (name === 'all countries' || name === 'all countries combined') tr.remove();
    });
    auvHtml = tmp3.innerHTML;
  } catch (e) { /* no-op */ }
  
  slicedPivotAvg.innerHTML = auvHtml;
  pivotContainer.innerHTML = origPivotHTML;
  
  // =========================
  // NEGLIGIBILITY ANALYSIS
  // =========================
  renderNegligibilityAnalysis(rows);
  slicedNeg.innerHTML = negContainer.innerHTML;
  negContainer.innerHTML = origNegHTML;
  
  // =========================
  // ADD TOGGLE CONTROLS
  // =========================
  repositionCloneToggles();
}

// Also add this function for the toggle controls:
function repositionCloneToggles() {
  // Hide original toggle container
  const toggleContainer = document.querySelector('.toggle-container');
  if (toggleContainer) {
    toggleContainer.style.display = 'none';
  }
  
  // Add toggle to quantity heading
  const qtyContainer = document.getElementById('slicedPivotContainer');
  if (qtyContainer) {
    const header = qtyContainer.querySelector('h3');
    if (header) {
      header.classList.add('pivot-title');
      // Remove previous clone if exists
      const prev = header.querySelector('.pivot-toggle');
      if (prev) prev.remove();
      
      const wrapper = document.createElement('span');
      wrapper.className = 'pivot-toggle';
      
      const label = document.createElement('span');
      label.textContent = 'Quantity Unit:';
      wrapper.appendChild(label);
      
      const original = document.getElementById('unitToggle');
      if (original) {
        const clone = original.cloneNode(true);
        clone.id = 'unitToggleClone';
        clone.value = original.value;
        clone.addEventListener('change', () => {
          original.value = clone.value;
          original.dispatchEvent(new Event('change'));
        });
        wrapper.appendChild(clone);
      }
      
      header.appendChild(wrapper);
    }
  }
  
  // Add toggle to value heading
  const valContainer = document.getElementById('slicedPivotValueContainer');
  if (valContainer) {
    const header = valContainer.querySelector('h3');
    if (header) {
      header.classList.add('pivot-title');
      const prev = header.querySelector('.pivot-toggle');
      if (prev) prev.remove();
      
      const wrapper = document.createElement('span');
      wrapper.className = 'pivot-toggle';
      
      const label = document.createElement('span');
      label.textContent = 'Value Type:';
      wrapper.appendChild(label);
      
      const original = document.getElementById('valueToggle');
      if (original) {
        const clone = original.cloneNode(true);
        clone.id = 'valueToggleClone';
        clone.value = original.value;
        clone.addEventListener('change', () => {
          original.value = clone.value;
          original.dispatchEvent(new Event('change'));
        });
        wrapper.appendChild(clone);
      }
      
      header.appendChild(wrapper);
    }
  }
}
    // CSV Download
    function downloadCSV() {
      if (!currentTableRows || currentTableRows.length === 0) return;
      
      const valueLabel = useCustomsValue ? 'Customs Value (Dollars)' : 'LDP Value (Dollars)';
      const qtyLabel = useSecondUnit ? 'Quantity (2nd unit)' : 'Quantity (1st unit)';
      const header = ['Date','HTS Code','Country Code','Country Name', valueLabel, qtyLabel];
      const lines = [];
      lines.push(header.join(','));
      
      currentTableRows.forEach(row => {
        const val = useCustomsValue ? (row.valueCustoms || 0) : (row.valueLDP || 0);
        const qty = useSecondUnit ? (row.quantity2 || 0) : (row.quantity1 || 0);
        const values = [
          row.date,
          row.code,
          row.country,
          row.countryName ? row.countryName.replace(/,/g, '') : '',
          val,
          qty
        ];
        lines.push(values.join(','));
      });
      
      const csvContent = lines.join('\n');
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `trade_data_${new Date().toISOString().split('T')[0]}.csv`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // ========================================
    // EVENT LISTENERS
    // ========================================
    document.addEventListener('DOMContentLoaded', () => {
      // Connect to API on page load
      connectToAPI();
      
      // Initialize toggle event listeners
      const unitToggleEl = document.getElementById('unitToggle');
      const valueToggleEl = document.getElementById('valueToggle');
      if (unitToggleEl) {
        unitToggleEl.addEventListener('change', () => {
          useSecondUnit = (unitToggleEl.value === '2');
          updateRowsBasedOnToggles();
        });
      }
      if (valueToggleEl) {
        valueToggleEl.addEventListener('change', () => {
          useCustomsValue = (valueToggleEl.value === 'customs');
          updateRowsBasedOnToggles();
        });
      }
      
      // Fetch button
      document.getElementById('fetchBtn').addEventListener('click', fetchData);
      
      // Download button
      document.getElementById('downloadBtn').addEventListener('click', downloadCSV);
      
      // Add country button
      document.getElementById('addCountryBtn').addEventListener('click', () => {
        const searchInput = document.getElementById('countrySearch');
        const searchText = searchInput.value.toLowerCase().trim();
        const select = document.getElementById('countrySelect');
        const options = select.options;
        
        if (searchText) {
          for (let i = 0; i < options.length; i++) {
            const opt = options[i];
            if (!opt.value) continue;
            if (opt.textContent.toLowerCase().includes(searchText)) {
              opt.selected = true;
              select.value = opt.value;
              if (typeof opt.scrollIntoView === 'function') {
                opt.scrollIntoView({ block: 'nearest' });
              }
              break;
            }
          }
        }
        
        const selectedOpts = Array.from(options).filter(opt => opt.selected && opt.value);
        selectedOpts.forEach(opt => {
          const exists = selectedCountriesList.some(entry => entry.code === opt.value);
          if (!exists) {
            selectedCountriesList.push({ code: opt.value, name: opt.textContent });
          }
        });
        
        renderSelectedCountries();
        searchInput.value = '';
      });
      
      // Remove country button
      document.getElementById('removeCountryBtn').addEventListener('click', () => {
        const selectBox = document.getElementById('selectedCountrySelect');
        if (!selectBox) return;
        
        const selected = Array.from(selectBox.selectedOptions);
        if (selected.length === 0) return;
        
        const countrySelect = document.getElementById('countrySelect');
        selected.forEach(opt => {
          const code = opt.value;
          selectedCountriesList = selectedCountriesList.filter(entry => entry.code !== code);
          Array.from(countrySelect.options).forEach(o => {
            if (o.value === code) {
              o.selected = false;
            }
          });
        });
        
        renderSelectedCountries();
      });
      
      // Country search on type
      const searchBox = document.getElementById('countrySearch');
      const countrySelect = document.getElementById('countrySelect');
      if (searchBox && countrySelect) {
        searchBox.addEventListener('input', () => {
          const term = searchBox.value.toLowerCase().trim();
          const opts = Array.from(countrySelect.options);
          opts.forEach(opt => { opt.selected = false; });
          
          if (!term) return;
          
          for (const opt of opts) {
            if (!opt.value) continue;
            if (opt.textContent.toLowerCase().includes(term)) {
              opt.selected = true;
              countrySelect.value = opt.value;
              if (typeof opt.scrollIntoView === 'function') {
                opt.scrollIntoView({ block: 'nearest' });
              }
              break;
            }
          }
        });
      }
    });

    // ========================================
    // SUCCESS MESSAGE
    // ========================================
    console.log('%c🔒 TradeVRS Advanced Platform Loaded!', 'color: green; font-size: 16px; font-weight: bold;');
    console.log('%c✅ Secure Backend: Country codes and units protected', 'color: blue; font-size: 12px;');
    console.log('%c✅ Census API: Real-time trade data integration', 'color: blue; font-size: 12px;');
    console.log('%c✅ Advanced Features: Pivot tables, filters, and analysis tools', 'color: blue; font-size: 12px;');
  </script>
</body>
</html>
